1: I'll help you implement the necessary changes to fix the issue with `LEVEL_TAGS` not being updated when using `@override_settings`. Let's start by exploring the repository structure and understanding the problem.
>> str_replace_editor view /testbed
Here's the files and directories up to 2 levels deep in /testbed, excluding hidden items:
/testbed
/testbed/scripts
/testbed/scripts/manage_translations.py
/testbed/scripts/rpm-install.sh
/testbed/AUTHORS
/testbed/LICENSE.python
/testbed/package.json
/testbed/README.rst
/testbed/MANIFEST.in
/testbed/django
/testbed/django/apps
/testbed/django/utils
/testbed/django/http
/testbed/django/test
/testbed/django/db
/testbed/django/urls
/testbed/django/core
/testbed/django/views
/testbed/django/dispatch
/testbed/django/contrib
/testbed/django/template
/testbed/django/__main__.py
/testbed/django/conf
/testbed/django/__init__.py
/testbed/django/shortcuts.py
/testbed/django/__pycache__
/testbed/django/forms
/testbed/django/middleware
/testbed/django/templatetags
/testbed/setup.py
/testbed/setup.cfg
/testbed/pyproject.toml
/testbed/Gruntfile.js
/testbed/CONTRIBUTING.rst
/testbed/js_tests
/testbed/js_tests/admin
/testbed/js_tests/tests.html
/testbed/js_tests/gis
/testbed/INSTALL
/testbed/tox.ini
/testbed/tests
/testbed/tests/apps
/testbed/tests/custom_columns
/testbed/tests/db_functions
/testbed/tests/logging_tests
/testbed/tests/generic_relations
/testbed/tests/resolve_url
/testbed/tests/filtered_relation
/testbed/tests/many_to_one
/testbed/tests/managers_regress
/testbed/tests/test_runner_apps
/testbed/tests/reverse_lookup
/testbed/tests/migrations2
/testbed/tests/m2m_signals
/testbed/tests/fixtures_model_package
/testbed/tests/async
/testbed/tests/README.rst
/testbed/tests/datetimes
/testbed/tests/settings_tests
/testbed/tests/fixtures
/testbed/tests/introspection
/testbed/tests/shell
/testbed/tests/backends
/testbed/tests/admin_ordering
/testbed/tests/foreign_object
/testbed/tests/pagination
/testbed/tests/defer
/testbed/tests/admin_custom_urls
/testbed/tests/contenttypes_tests
/testbed/tests/timezones
/testbed/tests/migration_test_data_persistence
/testbed/tests/field_subclassing
/testbed/tests/model_inheritance_regress
/testbed/tests/signed_cookies_tests
/testbed/tests/sitemaps_tests
/testbed/tests/serializers
/testbed/tests/model_formsets_regress
/testbed/tests/auth_tests
/testbed/tests/middleware_exceptions
/testbed/tests/test_client_regress
/testbed/tests/from_db_value
/testbed/tests/raw_query
/testbed/tests/m2m_multiple
/testbed/tests/model_indexes
/testbed/tests/file_storage
/testbed/tests/urlpatterns
/testbed/tests/custom_migration_operations
/testbed/tests/update
/testbed/tests/file_uploads
/testbed/tests/csrf_tests
/testbed/tests/mutually_referential
/testbed/tests/shortcuts
/testbed/tests/reserved_names
/testbed/tests/sites_framework
/testbed/tests/redirects_tests
/testbed/tests/admin_filters
/testbed/tests/model_options
/testbed/tests/forms_tests
/testbed/tests/i18n
/testbed/tests/signing
/testbed/tests/decorators
/testbed/tests/test_sqlite.py
/testbed/tests/nested_foreign_keys
/testbed/tests/generic_views
/testbed/tests/dispatch
/testbed/tests/servers
/testbed/tests/no_models
/testbed/tests/utils_tests
/testbed/tests/files
/testbed/tests/postgres_tests
/testbed/tests/db_typecasts
/testbed/tests/modeladmin
/testbed/tests/validation
/testbed/tests/many_to_one_null
/testbed/tests/import_error_package
/testbed/tests/conditional_processing
/testbed/tests/prefetch_related
/testbed/tests/get_or_create
/testbed/tests/distinct_on_fields
/testbed/tests/constraints
/testbed/tests/db_utils
/testbed/tests/empty_models
/testbed/tests/update_only_fields
/testbed/tests/sessions_tests
/testbed/tests/force_insert_update
/testbed/tests/queries
/testbed/tests/schema
/testbed/tests/null_fk_ordering
/testbed/tests/proxy_models
/testbed/tests/transaction_hooks
/testbed/tests/asgi
/testbed/tests/lookup
/testbed/tests/dates
/testbed/tests/model_forms
/testbed/tests/test_exceptions
/testbed/tests/context_processors
/testbed/tests/signals
/testbed/tests/migrate_signals
/testbed/tests/many_to_many
/testbed/tests/get_earliest_or_latest
/testbed/tests/humanize_tests
/testbed/tests/check_framework
/testbed/tests/admin_inlines
/testbed/tests/absolute_url_overrides
/testbed/tests/extra_regress
/testbed/tests/multiple_database
/testbed/tests/handlers
/testbed/tests/project_template
/testbed/tests/basic
/testbed/tests/admin_changelist
/testbed/tests/runtests.py
/testbed/tests/get_object_or_404
/testbed/tests/template_tests
/testbed/tests/invalid_models_tests
/testbed/tests/m2m_through_regress
/testbed/tests/template_backends
/testbed/tests/admin_registration
/testbed/tests/admin_checks
/testbed/tests/gis_tests
/testbed/tests/admin_autodiscover
/testbed/tests/test_client
/testbed/tests/inline_formsets
/testbed/tests/urls.py
/testbed/tests/aggregation
/testbed/tests/inspectdb
/testbed/tests/model_fields
/testbed/tests/mail
/testbed/tests/m2m_through
/testbed/tests/bulk_create
/testbed/tests/custom_methods
/testbed/tests/urlpatterns_reverse
/testbed/tests/known_related_objects
/testbed/tests/delete_regress
/testbed/tests/save_delete_hooks
/testbed/tests/user_commands
/testbed/tests/version
/testbed/tests/indexes
/testbed/tests/m2m_recursive
/testbed/tests/validators
/testbed/tests/dbshell
/testbed/tests/flatpages_tests
/testbed/tests/generic_relations_regress
/testbed/tests/m2m_intermediary
/testbed/tests/custom_managers
/testbed/tests/base
/testbed/tests/field_defaults
/testbed/tests/admin_utils
/testbed/tests/model_utils
/testbed/tests/model_regress
/testbed/tests/null_fk
/testbed/tests/migrations
/testbed/tests/select_related_onetoone
/testbed/tests/model_package
/testbed/tests/messages_tests
/testbed/tests/or_lookups
/testbed/tests/requirements
/testbed/tests/responses
/testbed/tests/model_meta
/testbed/tests/swappable_models
/testbed/tests/requests
/testbed/tests/m2m_regress
/testbed/tests/m2m_and_m2o
/testbed/tests/one_to_one
/testbed/tests/model_inheritance
/testbed/tests/m2o_recursive
/testbed/tests/select_related
/testbed/tests/defer_regress
/testbed/tests/admin_default_site
/testbed/tests/model_formsets
/testbed/tests/admin_scripts
/testbed/tests/template_loader
/testbed/tests/app_loading
/testbed/tests/ordering
/testbed/tests/field_deconstruction
/testbed/tests/generic_inline_admin
/testbed/tests/fixtures_regress
/testbed/tests/select_for_update
/testbed/tests/middleware
/testbed/tests/string_lookup
/testbed/tests/annotations
/testbed/tests/admin_views
/testbed/tests/expressions_window
/testbed/tests/admin_docs
/testbed/tests/properties
/testbed/tests/expressions
/testbed/tests/test_utils
/testbed/tests/delete
/testbed/tests/select_related_regress
/testbed/tests/templates
/testbed/tests/aggregation_regress
/testbed/tests/order_with_respect_to
/testbed/tests/str
/testbed/tests/view_tests
/testbed/tests/test_runner
/testbed/tests/builtin_server
/testbed/tests/custom_pk
/testbed/tests/sites_tests
/testbed/tests/datatypes
/testbed/tests/httpwrappers
/testbed/tests/syndication_tests
/testbed/tests/deprecation
/testbed/tests/queryset_pickle
/testbed/tests/staticfiles_tests
/testbed/tests/empty
/testbed/tests/model_enums
/testbed/tests/custom_lookups
/testbed/tests/wsgi
/testbed/tests/cache
/testbed/tests/admin_widgets
/testbed/tests/unmanaged_models
/testbed/tests/max_lengths
/testbed/tests/bash_completion
/testbed/tests/expressions_case
/testbed/tests/transactions
/testbed/tests/proxy_model_inheritance
/testbed/tests/null_queries
/testbed/extras
/testbed/extras/README.TXT
/testbed/extras/Makefile
/testbed/extras/django_bash_completion
/testbed/LICENSE
/testbed/docs
/testbed/docs/glossary.txt
/testbed/docs/contents.txt
/testbed/docs/README.rst
/testbed/docs/releases
/testbed/docs/requirements.txt
/testbed/docs/_ext
/testbed/docs/misc
/testbed/docs/conf.py
/testbed/docs/howto
/testbed/docs/topics
/testbed/docs/internals
/testbed/docs/Makefile
/testbed/docs/faq
/testbed/docs/man
/testbed/docs/make.bat
/testbed/docs/_theme
/testbed/docs/intro
/testbed/docs/index.txt
/testbed/docs/ref
/testbed/docs/spelling_wordlist
/testbed/Django.egg-info
/testbed/Django.egg-info/requires.txt
/testbed/Django.egg-info/entry_points.txt
/testbed/Django.egg-info/SOURCES.txt
/testbed/Django.egg-info/not-zip-safe
/testbed/Django.egg-info/dependency_links.txt
/testbed/Django.egg-info/top_level.txt
/testbed/Django.egg-info/PKG-INFO
--------------------------------------------------------------------------------
2: Now let's look at the messages framework, which is mentioned in the PR description:
>> str_replace_editor view /testbed/django/contrib/messages
Here's the files and directories up to 2 levels deep in /testbed/django/contrib/messages, excluding hidden items:
/testbed/django/contrib/messages
/testbed/django/contrib/messages/storage
/testbed/django/contrib/messages/storage/base.py
/testbed/django/contrib/messages/storage/__init__.py
/testbed/django/contrib/messages/storage/fallback.py
/testbed/django/contrib/messages/storage/session.py
/testbed/django/contrib/messages/storage/cookie.py
/testbed/django/contrib/messages/middleware.py
/testbed/django/contrib/messages/api.py
/testbed/django/contrib/messages/context_processors.py
/testbed/django/contrib/messages/__init__.py
/testbed/django/contrib/messages/views.py
/testbed/django/contrib/messages/utils.py
/testbed/django/contrib/messages/constants.py
/testbed/django/contrib/messages/apps.py
--------------------------------------------------------------------------------
3: Let's examine the base storage module since the PR mentions `django.contrib.messages.storage.base.Message.level_tag`:
>> str_replace_editor view /testbed/django/contrib/messages/storage/base.py
Here's the result of running `cat -n` on /testbed/django/contrib/messages/storage/base.py:
     1	from django.conf import settings
     2	from django.contrib.messages import constants, utils
     3	
     4	LEVEL_TAGS = utils.get_level_tags()
     5	
     6	
     7	class Message:
     8	    """
     9	    Represent an actual message that can be stored in any of the supported
    10	    storage classes (typically session- or cookie-based) and rendered in a view
    11	    or template.
    12	    """
    13	
    14	    def __init__(self, level, message, extra_tags=None):
    15	        self.level = int(level)
    16	        self.message = message
    17	        self.extra_tags = extra_tags
    18	
    19	    def _prepare(self):
    20	        """
    21	        Prepare the message for serialization by forcing the ``message``
    22	        and ``extra_tags`` to str in case they are lazy translations.
    23	        """
    24	        self.message = str(self.message)
    25	        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None
    26	
    27	    def __eq__(self, other):
    28	        if not isinstance(other, Message):
    29	            return NotImplemented
    30	        return self.level == other.level and self.message == other.message
    31	
    32	    def __str__(self):
    33	        return str(self.message)
    34	
    35	    @property
    36	    def tags(self):
    37	        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)
    38	
    39	    @property
    40	    def level_tag(self):
    41	        return LEVEL_TAGS.get(self.level, '')
    42	
    43	
    44	class BaseStorage:
    45	    """
    46	    This is the base backend for temporary message storage.
    47	
    48	    This is not a complete class; to be a usable storage backend, it must be
    49	    subclassed and the two methods ``_get`` and ``_store`` overridden.
    50	    """
    51	
    52	    def __init__(self, request, *args, **kwargs):
    53	        self.request = request
    54	        self._queued_messages = []
    55	        self.used = False
    56	        self.added_new = False
    57	        super().__init__(*args, **kwargs)
    58	
    59	    def __len__(self):
    60	        return len(self._loaded_messages) + len(self._queued_messages)
    61	
    62	    def __iter__(self):
    63	        self.used = True
    64	        if self._queued_messages:
    65	            self._loaded_messages.extend(self._queued_messages)
    66	            self._queued_messages = []
    67	        return iter(self._loaded_messages)
    68	
    69	    def __contains__(self, item):
    70	        return item in self._loaded_messages or item in self._queued_messages
    71	
    72	    def __repr__(self):
    73	        return f'<{self.__class__.__qualname__}: request={self.request!r}>'
    74	
    75	    @property
    76	    def _loaded_messages(self):
    77	        """
    78	        Return a list of loaded messages, retrieving them first if they have
    79	        not been loaded yet.
    80	        """
    81	        if not hasattr(self, '_loaded_data'):
    82	            messages, all_retrieved = self._get()
    83	            self._loaded_data = messages or []
    84	        return self._loaded_data
    85	
    86	    def _get(self, *args, **kwargs):
    87	        """
    88	        Retrieve a list of stored messages. Return a tuple of the messages
    89	        and a flag indicating whether or not all the messages originally
    90	        intended to be stored in this storage were, in fact, stored and
    91	        retrieved; e.g., ``(messages, all_retrieved)``.
    92	
    93	        **This method must be implemented by a subclass.**
    94	
    95	        If it is possible to tell if the backend was not used (as opposed to
    96	        just containing no messages) then ``None`` should be returned in
    97	        place of ``messages``.
    98	        """
    99	        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')
   100	
   101	    def _store(self, messages, response, *args, **kwargs):
   102	        """
   103	        Store a list of messages and return a list of any messages which could
   104	        not be stored.
   105	
   106	        One type of object must be able to be stored, ``Message``.
   107	
   108	        **This method must be implemented by a subclass.**
   109	        """
   110	        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')
   111	
   112	    def _prepare_messages(self, messages):
   113	        """
   114	        Prepare a list of messages for storage.
   115	        """
   116	        for message in messages:
   117	            message._prepare()
   118	
   119	    def update(self, response):
   120	        """
   121	        Store all unread messages.
   122	
   123	        If the backend has yet to be iterated, store previously stored messages
   124	        again. Otherwise, only store messages added after the last iteration.
   125	        """
   126	        self._prepare_messages(self._queued_messages)
   127	        if self.used:
   128	            return self._store(self._queued_messages, response)
   129	        elif self.added_new:
   130	            messages = self._loaded_messages + self._queued_messages
   131	            return self._store(messages, response)
   132	
   133	    def add(self, level, message, extra_tags=''):
   134	        """
   135	        Queue a message to be stored.
   136	
   137	        The message is only queued if it contained something and its level is
   138	        not less than the recording level (``self.level``).
   139	        """
   140	        if not message:
   141	            return
   142	        # Check that the message level is not less than the recording level.
   143	        level = int(level)
   144	        if level < self.level:
   145	            return
   146	        # Add the message.
   147	        self.added_new = True
   148	        message = Message(level, message, extra_tags=extra_tags)
   149	        self._queued_messages.append(message)
   150	
   151	    def _get_level(self):
   152	        """
   153	        Return the minimum recorded level.
   154	
   155	        The default level is the ``MESSAGE_LEVEL`` setting. If this is
   156	        not found, the ``INFO`` level is used.
   157	        """
   158	        if not hasattr(self, '_level'):
   159	            self._level = getattr(settings, 'MESSAGE_LEVEL', constants.INFO)
   160	        return self._level
   161	
   162	    def _set_level(self, value=None):
   163	        """
   164	        Set a custom minimum recorded level.
   165	
   166	        If set to ``None``, the default level will be used (see the
   167	        ``_get_level`` method).
   168	        """
   169	        if value is None and hasattr(self, '_level'):
   170	            del self._level
   171	        else:
   172	            self._level = int(value)
   173	
   174	    level = property(_get_level, _set_level, _set_level)
   175
--------------------------------------------------------------------------------
4: Now let's look at the utils module to understand how `get_level_tags()` works:
>> str_replace_editor view /testbed/django/contrib/messages/utils.py
Here's the result of running `cat -n` on /testbed/django/contrib/messages/utils.py:
     1	from django.conf import settings
     2	from django.contrib.messages import constants
     3	
     4	
     5	def get_level_tags():
     6	    """
     7	    Return the message level tags.
     8	    """
     9	    return {
    10	        **constants.DEFAULT_TAGS,
    11	        **getattr(settings, 'MESSAGE_TAGS', {}),
    12	    }
    13
--------------------------------------------------------------------------------
5: Let's also check the constants module:
>> str_replace_editor view /testbed/django/contrib/messages/constants.py
Here's the result of running `cat -n` on /testbed/django/contrib/messages/constants.py:
     1	DEBUG = 10
     2	INFO = 20
     3	SUCCESS = 25
     4	WARNING = 30
     5	ERROR = 40
     6	
     7	DEFAULT_TAGS = {
     8	    DEBUG: 'debug',
     9	    INFO: 'info',
    10	    SUCCESS: 'success',
    11	    WARNING: 'warning',
    12	    ERROR: 'error',
    13	}
    14	
    15	DEFAULT_LEVELS = {
    16	    'DEBUG': DEBUG,
    17	    'INFO': INFO,
    18	    'SUCCESS': SUCCESS,
    19	    'WARNING': WARNING,
    20	    'ERROR': ERROR,
    21	}
    22
--------------------------------------------------------------------------------
6: Now let's look at the messages tests to understand the issue better:
>> str_replace_editor view /testbed/tests/messages_tests
Here's the files and directories up to 2 levels deep in /testbed/tests/messages_tests, excluding hidden items:
/testbed/tests/messages_tests
/testbed/tests/messages_tests/test_middleware.py
/testbed/tests/messages_tests/base.py
/testbed/tests/messages_tests/models.py
/testbed/tests/messages_tests/test_session.py
/testbed/tests/messages_tests/test_fallback.py
/testbed/tests/messages_tests/test_api.py
/testbed/tests/messages_tests/tests.py
/testbed/tests/messages_tests/urls.py
/testbed/tests/messages_tests/__init__.py
/testbed/tests/messages_tests/test_cookie.py
/testbed/tests/messages_tests/test_mixins.py
--------------------------------------------------------------------------------
7: Let's look at the main tests file to understand how the issue manifests:
>> str_replace_editor view /testbed/tests/messages_tests/tests.py
Here's the result of running `cat -n` on /testbed/tests/messages_tests/tests.py:
     1	from unittest import mock
     2	
     3	from django.contrib.messages import constants
     4	from django.contrib.messages.storage.base import Message
     5	from django.test import SimpleTestCase
     6	
     7	
     8	class MessageTests(SimpleTestCase):
     9	    def test_eq(self):
    10	        msg_1 = Message(constants.INFO, 'Test message 1')
    11	        msg_2 = Message(constants.INFO, 'Test message 2')
    12	        msg_3 = Message(constants.WARNING, 'Test message 1')
    13	        self.assertEqual(msg_1, msg_1)
    14	        self.assertEqual(msg_1, mock.ANY)
    15	        self.assertNotEqual(msg_1, msg_2)
    16	        self.assertNotEqual(msg_1, msg_3)
    17	        self.assertNotEqual(msg_2, msg_3)
    18
--------------------------------------------------------------------------------
8: Let's also check the base test file:
>> str_replace_editor view /testbed/tests/messages_tests/base.py
Here's the result of running `cat -n` on /testbed/tests/messages_tests/base.py:
     1	from django.contrib.messages import constants, get_level, set_level, utils
     2	from django.contrib.messages.api import MessageFailure
     3	from django.contrib.messages.constants import DEFAULT_LEVELS
     4	from django.contrib.messages.storage import base, default_storage
     5	from django.contrib.messages.storage.base import Message
     6	from django.http import HttpRequest, HttpResponse
     7	from django.test import modify_settings, override_settings
     8	from django.urls import reverse
     9	from django.utils.translation import gettext_lazy
    10	
    11	
    12	def add_level_messages(storage):
    13	    """
    14	    Add 6 messages from different levels (including a custom one) to a storage
    15	    instance.
    16	    """
    17	    storage.add(constants.INFO, 'A generic info message')
    18	    storage.add(29, 'Some custom level')
    19	    storage.add(constants.DEBUG, 'A debugging message', extra_tags='extra-tag')
    20	    storage.add(constants.WARNING, 'A warning')
    21	    storage.add(constants.ERROR, 'An error')
    22	    storage.add(constants.SUCCESS, 'This was a triumph.')
    23	
    24	
    25	class override_settings_tags(override_settings):
    26	    def enable(self):
    27	        super().enable()
    28	        # LEVEL_TAGS is a constant defined in the
    29	        # django.contrib.messages.storage.base module, so after changing
    30	        # settings.MESSAGE_TAGS, update that constant also.
    31	        self.old_level_tags = base.LEVEL_TAGS
    32	        base.LEVEL_TAGS = utils.get_level_tags()
    33	
    34	    def disable(self):
    35	        super().disable()
    36	        base.LEVEL_TAGS = self.old_level_tags
    37	
    38	
    39	class BaseTests:
    40	    storage_class = default_storage
    41	    levels = {
    42	        'debug': constants.DEBUG,
    43	        'info': constants.INFO,
    44	        'success': constants.SUCCESS,
    45	        'warning': constants.WARNING,
    46	        'error': constants.ERROR,
    47	    }
    48	
    49	    def setUp(self):
    50	        self.settings_override = override_settings_tags(
    51	            TEMPLATES=[{
    52	                'BACKEND': 'django.template.backends.django.DjangoTemplates',
    53	                'DIRS': [],
    54	                'APP_DIRS': True,
    55	                'OPTIONS': {
    56	                    'context_processors': (
    57	                        'django.contrib.auth.context_processors.auth',
    58	                        'django.contrib.messages.context_processors.messages',
    59	                    ),
    60	                },
    61	            }],
    62	            ROOT_URLCONF='messages_tests.urls',
    63	            MESSAGE_TAGS={},
    64	            MESSAGE_STORAGE='%s.%s' % (self.storage_class.__module__, self.storage_class.__name__),
    65	            SESSION_SERIALIZER='django.contrib.sessions.serializers.JSONSerializer',
    66	        )
    67	        self.settings_override.enable()
    68	
    69	    def tearDown(self):
    70	        self.settings_override.disable()
    71	
    72	    def get_request(self):
    73	        return HttpRequest()
    74	
    75	    def get_response(self):
    76	        return HttpResponse()
    77	
    78	    def get_storage(self, data=None):
    79	        """
    80	        Return the storage backend, setting its loaded data to the ``data``
    81	        argument.
    82	
    83	        This method avoids the storage ``_get`` method from getting called so
    84	        that other parts of the storage backend can be tested independent of
    85	        the message retrieval logic.
    86	        """
    87	        storage = self.storage_class(self.get_request())
    88	        storage._loaded_data = data or []
    89	        return storage
    90	
    91	    def test_repr(self):
    92	        request = self.get_request()
    93	        storage = self.storage_class(request)
    94	        self.assertEqual(
    95	            repr(storage),
    96	            f'<{self.storage_class.__qualname__}: request=<HttpRequest>>',
    97	        )
    98	
    99	    def test_add(self):
   100	        storage = self.get_storage()
   101	        self.assertFalse(storage.added_new)
   102	        storage.add(constants.INFO, 'Test message 1')
   103	        self.assertTrue(storage.added_new)
   104	        storage.add(constants.INFO, 'Test message 2', extra_tags='tag')
   105	        self.assertEqual(len(storage), 2)
   106	
   107	    def test_add_lazy_translation(self):
   108	        storage = self.get_storage()
   109	        response = self.get_response()
   110	
   111	        storage.add(constants.INFO, gettext_lazy('lazy message'))
   112	        storage.update(response)
   113	
   114	        storing = self.stored_messages_count(storage, response)
   115	        self.assertEqual(storing, 1)
   116	
   117	    def test_no_update(self):
   118	        storage = self.get_storage()
   119	        response = self.get_response()
   120	        storage.update(response)
   121	        storing = self.stored_messages_count(storage, response)
   122	        self.assertEqual(storing, 0)
   123	
   124	    def test_add_update(self):
   125	        storage = self.get_storage()
   126	        response = self.get_response()
   127	
   128	        storage.add(constants.INFO, 'Test message 1')
   129	        storage.add(constants.INFO, 'Test message 1', extra_tags='tag')
   130	        storage.update(response)
   131	
   132	        storing = self.stored_messages_count(storage, response)
   133	        self.assertEqual(storing, 2)
   134	
   135	    def test_existing_add_read_update(self):
   136	        storage = self.get_existing_storage()
   137	        response = self.get_response()
   138	
   139	        storage.add(constants.INFO, 'Test message 3')
   140	        list(storage)   # Simulates a read
   141	        storage.update(response)
   142	
   143	        storing = self.stored_messages_count(storage, response)
   144	        self.assertEqual(storing, 0)
   145	
   146	    def test_existing_read_add_update(self):
   147	        storage = self.get_existing_storage()
   148	        response = self.get_response()
   149	
   150	        list(storage)   # Simulates a read
   151	        storage.add(constants.INFO, 'Test message 3')
   152	        storage.update(response)
   153	
   154	        storing = self.stored_messages_count(storage, response)
   155	        self.assertEqual(storing, 1)
   156	
   157	    @override_settings(MESSAGE_LEVEL=constants.DEBUG)
   158	    def test_full_request_response_cycle(self):
   159	        """
   160	        With the message middleware enabled, messages are properly stored and
   161	        retrieved across the full request/redirect/response cycle.
   162	        """
   163	        data = {
   164	            'messages': ['Test message %d' % x for x in range(5)],
   165	        }
   166	        show_url = reverse('show_message')
   167	        for level in ('debug', 'info', 'success', 'warning', 'error'):
   168	            add_url = reverse('add_message', args=(level,))
   169	            response = self.client.post(add_url, data, follow=True)
   170	            self.assertRedirects(response, show_url)
   171	            self.assertIn('messages', response.context)
   172	            messages = [Message(self.levels[level], msg) for msg in data['messages']]
   173	            self.assertEqual(list(response.context['messages']), messages)
   174	            for msg in data['messages']:
   175	                self.assertContains(response, msg)
   176	
   177	    @override_settings(MESSAGE_LEVEL=constants.DEBUG)
   178	    def test_with_template_response(self):
   179	        data = {
   180	            'messages': ['Test message %d' % x for x in range(5)],
   181	        }
   182	        show_url = reverse('show_template_response')
   183	        for level in self.levels:
   184	            add_url = reverse('add_template_response', args=(level,))
   185	            response = self.client.post(add_url, data, follow=True)
   186	            self.assertRedirects(response, show_url)
   187	            self.assertIn('messages', response.context)
   188	            for msg in data['messages']:
   189	                self.assertContains(response, msg)
   190	
   191	            # there shouldn't be any messages on second GET request
   192	            response = self.client.get(show_url)
   193	            for msg in data['messages']:
   194	                self.assertNotContains(response, msg)
   195	
   196	    def test_context_processor_message_levels(self):
   197	        show_url = reverse('show_template_response')
   198	        response = self.client.get(show_url)
   199	
   200	        self.assertIn('DEFAULT_MESSAGE_LEVELS', response.context)
   201	        self.assertEqual(response.context['DEFAULT_MESSAGE_LEVELS'], DEFAULT_LEVELS)
   202	
   203	    @override_settings(MESSAGE_LEVEL=constants.DEBUG)
   204	    def test_multiple_posts(self):
   205	        """
   206	        Messages persist properly when multiple POSTs are made before a GET.
   207	        """
   208	        data = {
   209	            'messages': ['Test message %d' % x for x in range(5)],
   210	        }
   211	        show_url = reverse('show_message')
   212	        messages = []
   213	        for level in ('debug', 'info', 'success', 'warning', 'error'):
   214	            messages.extend(Message(self.levels[level], msg) for msg in data['messages'])
   215	            add_url = reverse('add_message', args=(level,))
   216	            self.client.post(add_url, data)
   217	        response = self.client.get(show_url)
   218	        self.assertIn('messages', response.context)
   219	        self.assertEqual(list(response.context['messages']), messages)
   220	        for msg in data['messages']:
   221	            self.assertContains(response, msg)
   222	
   223	    @modify_settings(
   224	        INSTALLED_APPS={'remove': 'django.contrib.messages'},
   225	        MIDDLEWARE={'remove': 'django.contrib.messages.middleware.MessageMiddleware'},
   226	    )
   227	    @override_settings(
   228	        MESSAGE_LEVEL=constants.DEBUG,
   229	        TEMPLATES=[{
   230	            'BACKEND': 'django.template.backends.django.DjangoTemplates',
   231	            'DIRS': [],
   232	            'APP_DIRS': True,
   233	        }],
   234	    )
   235	    def test_middleware_disabled(self):
   236	        """
   237	        When the middleware is disabled, an exception is raised when one
   238	        attempts to store a message.
   239	        """
   240	        data = {
   241	            'messages': ['Test message %d' % x for x in range(5)],
   242	        }
   243	        reverse('show_message')
   244	        for level in ('debug', 'info', 'success', 'warning', 'error'):
   245	            add_url = reverse('add_message', args=(level,))
   246	            with self.assertRaises(MessageFailure):
   247	                self.client.post(add_url, data, follow=True)
   248	
   249	    @modify_settings(
   250	        INSTALLED_APPS={'remove': 'django.contrib.messages'},
   251	        MIDDLEWARE={'remove': 'django.contrib.messages.middleware.MessageMiddleware'},
   252	    )
   253	    @override_settings(
   254	        TEMPLATES=[{
   255	            'BACKEND': 'django.template.backends.django.DjangoTemplates',
   256	            'DIRS': [],
   257	            'APP_DIRS': True,
   258	        }],
   259	    )
   260	    def test_middleware_disabled_fail_silently(self):
   261	        """
   262	        When the middleware is disabled, an exception is not raised
   263	        if 'fail_silently' is True.
   264	        """
   265	        data = {
   266	            'messages': ['Test message %d' % x for x in range(5)],
   267	            'fail_silently': True,
   268	        }
   269	        show_url = reverse('show_message')
   270	        for level in ('debug', 'info', 'success', 'warning', 'error'):
   271	            add_url = reverse('add_message', args=(level,))
   272	            response = self.client.post(add_url, data, follow=True)
   273	            self.assertRedirects(response, show_url)
   274	            self.assertNotIn('messages', response.context)
   275	
   276	    def stored_messages_count(self, storage, response):
   277	        """
   278	        Return the number of messages being stored after a
   279	        ``storage.update()`` call.
   280	        """
   281	        raise NotImplementedError('This method must be set by a subclass.')
   282	
   283	    def test_get(self):
   284	        raise NotImplementedError('This method must be set by a subclass.')
   285	
   286	    def get_existing_storage(self):
   287	        return self.get_storage([
   288	            Message(constants.INFO, 'Test message 1'),
   289	            Message(constants.INFO, 'Test message 2', extra_tags='tag'),
   290	        ])
   291	
   292	    def test_existing_read(self):
   293	        """
   294	        Reading the existing storage doesn't cause the data to be lost.
   295	        """
   296	        storage = self.get_existing_storage()
   297	        self.assertFalse(storage.used)
   298	        # After iterating the storage engine directly, the used flag is set.
   299	        data = list(storage)
   300	        self.assertTrue(storage.used)
   301	        # The data does not disappear because it has been iterated.
   302	        self.assertEqual(data, list(storage))
   303	
   304	    def test_existing_add(self):
   305	        storage = self.get_existing_storage()
   306	        self.assertFalse(storage.added_new)
   307	        storage.add(constants.INFO, 'Test message 3')
   308	        self.assertTrue(storage.added_new)
   309	
   310	    def test_default_level(self):
   311	        # get_level works even with no storage on the request.
   312	        request = self.get_request()
   313	        self.assertEqual(get_level(request), constants.INFO)
   314	
   315	        # get_level returns the default level if it hasn't been set.
   316	        storage = self.get_storage()
   317	        request._messages = storage
   318	        self.assertEqual(get_level(request), constants.INFO)
   319	
   320	        # Only messages of sufficient level get recorded.
   321	        add_level_messages(storage)
   322	        self.assertEqual(len(storage), 5)
   323	
   324	    def test_low_level(self):
   325	        request = self.get_request()
   326	        storage = self.storage_class(request)
   327	        request._messages = storage
   328	
   329	        self.assertTrue(set_level(request, 5))
   330	        self.assertEqual(get_level(request), 5)
   331	
   332	        add_level_messages(storage)
   333	        self.assertEqual(len(storage), 6)
   334	
   335	    def test_high_level(self):
   336	        request = self.get_request()
   337	        storage = self.storage_class(request)
   338	        request._messages = storage
   339	
   340	        self.assertTrue(set_level(request, 30))
   341	        self.assertEqual(get_level(request), 30)
   342	
   343	        add_level_messages(storage)
   344	        self.assertEqual(len(storage), 2)
   345	
   346	    @override_settings(MESSAGE_LEVEL=29)
   347	    def test_settings_level(self):
   348	        request = self.get_request()
   349	        storage = self.storage_class(request)
   350	
   351	        self.assertEqual(get_level(request), 29)
   352	
   353	        add_level_messages(storage)
   354	        self.assertEqual(len(storage), 3)
   355	
   356	    def test_tags(self):
   357	        storage = self.get_storage()
   358	        storage.level = 0
   359	        add_level_messages(storage)
   360	        storage.add(constants.INFO, 'A generic info message', extra_tags=None)
   361	        tags = [msg.tags for msg in storage]
   362	        self.assertEqual(tags, ['info', '', 'extra-tag debug', 'warning', 'error', 'success', 'info'])
   363	
   364	    def test_level_tag(self):
   365	        storage = self.get_storage()
   366	        storage.level = 0
   367	        add_level_messages(storage)
   368	        tags = [msg.level_tag for msg in storage]
   369	        self.assertEqual(tags, ['info', '', 'debug', 'warning', 'error', 'success'])
   370	
   371	    @override_settings_tags(MESSAGE_TAGS={
   372	        constants.INFO: 'info',
   373	        constants.DEBUG: '',
   374	        constants.WARNING: '',
   375	        constants.ERROR: 'bad',
   376	        29: 'custom',
   377	    })
   378	    def test_custom_tags(self):
   379	        storage = self.get_storage()
   380	        storage.level = 0
   381	        add_level_messages(storage)
   382	        tags = [msg.tags for msg in storage]
   383	        self.assertEqual(tags, ['info', 'custom', 'extra-tag', '', 'bad', 'success'])
   384
--------------------------------------------------------------------------------
9: Now I can see the issue! Looking at line 4 in `/testbed/django/contrib/messages/storage/base.py`, we see:

```python
LEVEL_TAGS = utils.get_level_tags()
```

This line is executed at module import time, which means it captures the `MESSAGE_TAGS` setting value at that moment. When tests use `@override_settings` to change `MESSAGE_TAGS`, the `LEVEL_TAGS` constant is not updated because it was already evaluated.

However, I notice that in the test file, there's already a custom `override_settings_tags` class (lines 25-37 in base.py) that handles this issue by manually updating `base.LEVEL_TAGS` when settings are overridden. But the problem is that this custom class is only used in the test base class, not when regular `@override_settings` is used.

Let me create a script to reproduce the issue first:
>> str_replace_editor create /testbed/reproduce_issue.py --file_text '#!/usr/bin/env python
File created successfully at: /testbed/reproduce_issue.py
--------------------------------------------------------------------------------
10: 
>> cd /testbed && python reproduce_issue.py
=== Testing LEVEL_TAGS issue ===
Initial LEVEL_TAGS: {10: 'debug', 20: 'info', 25: 'success', 30: 'warning', 40: 'error'}
Message level: 35
Message level_tag (before override): ''
LEVEL_TAGS inside override_settings: {10: 'debug', 20: 'info', 25: 'success', 30: 'warning', 40: 'error'}
Message level_tag (inside override): ''
New message level_tag (inside override): ''
LEVEL_TAGS after override_settings: {10: 'debug', 20: 'info', 25: 'success', 30: 'warning', 40: 'error'}
Message level_tag (after override): ''
--------------------------------------------------------------------------------
11: Perfect! This confirms the issue. The `LEVEL_TAGS` constant is not being updated when `@override_settings` is used, so the `level_tag` property returns an empty string instead of the custom tag.

Now let's understand the problem better. The issue is that `LEVEL_TAGS` is a module-level constant that gets evaluated once when the module is imported. When `@override_settings` changes the `MESSAGE_TAGS` setting, the `LEVEL_TAGS` constant is not automatically updated.

The solution is to make the `level_tag` property dynamic so that it reads the current settings instead of relying on the cached `LEVEL_TAGS` constant.

Let's look at how the `level_tag` property is currently implemented:
>> str_replace_editor view /testbed/django/contrib/messages/storage/base.py  --view_range 39 42
Here's the result of running `cat -n` on /testbed/django/contrib/messages/storage/base.py:
    39	    @property
    40	    def level_tag(self):
    41	        return LEVEL_TAGS.get(self.level, '')
    42
--------------------------------------------------------------------------------
12: The fix is to change the `level_tag` property to call `utils.get_level_tags()` directly instead of using the cached `LEVEL_TAGS` constant. This way, it will always get the current settings.
>> str_replace_editor str_replace /testbed/django/contrib/messages/storage/base.py   --old_str '    @property
The file /testbed/django/contrib/messages/storage/base.py has been edited. Here's the result of running `cat -n` on a snippet of /testbed/django/contrib/messages/storage/base.py:
    34	
    35	    @property
    36	    def tags(self):
    37	        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)
    38	
    39	    @property
    40	    def level_tag(self):
    41	        return utils.get_level_tags().get(self.level, '')
    42	
    43	
    44	class BaseStorage:
Review the changes and make sure they are as expected. Edit the file again if necessary.
--------------------------------------------------------------------------------
13: Now let's test our fix:
>> cd /testbed && python reproduce_issue.py
=== Testing LEVEL_TAGS issue ===
Initial LEVEL_TAGS: {10: 'debug', 20: 'info', 25: 'success', 30: 'warning', 40: 'error'}
Message level: 35
Message level_tag (before override): ''
LEVEL_TAGS inside override_settings: {10: 'debug', 20: 'info', 25: 'success', 30: 'warning', 40: 'error'}
Message level_tag (inside override): 'custom'
New message level_tag (inside override): 'custom'
LEVEL_TAGS after override_settings: {10: 'debug', 20: 'info', 25: 'success', 30: 'warning', 40: 'error'}
Message level_tag (after override): ''
--------------------------------------------------------------------------------
14: Great! The fix is working. Now inside the `@override_settings` context, the `level_tag` property correctly returns 'custom' instead of an empty string.

Let's create a more comprehensive test to make sure our fix handles all edge cases:
>> str_replace_editor create /testbed/test_comprehensive.py --file_text '#!/usr/bin/env python
File created successfully at: /testbed/test_comprehensive.py
--------------------------------------------------------------------------------
15: 
>> cd /testbed && python test_comprehensive.py
=== Comprehensive LEVEL_TAGS test ===

1. Testing default tags:
INFO level_tag: 'info'
WARNING level_tag: 'warning'

2. Testing custom level without override:
Custom level 35 level_tag: ''

3. Testing custom level with override:
Custom level 35 level_tag: 'custom'
New custom message level_tag: 'custom'
INFO level_tag inside override: 'info'

4. Testing after override:
Custom level 35 level_tag: ''
INFO level_tag after override: 'info'

5. Testing override of existing default tag:
INFO level_tag with override: 'information'
INFO level_tag after override: 'info'

6. Testing multiple custom tags:
Level 35 level_tag: 'custom1'
Level 45 level_tag: 'custom2'

7. Testing tags property:
Error message tags: 'urgent error'
Error message tags with override: 'urgent danger'

=== All tests completed ===
--------------------------------------------------------------------------------
16: Excellent! Our fix is working perfectly for all test cases. The `level_tag` property now correctly reflects the current settings, including when they are overridden with `@override_settings`.

Now let's run the existing Django tests to make sure we didn't break anything:
>> cd /testbed && python -m pytest tests/messages_tests/ -v
/opt/miniconda3/envs/testbed/bin/python: No module named pytest
--------------------------------------------------------------------------------
17: Let's use Django's test runner instead:
>> cd /testbed && python -m django test messages_tests --settings=tests.test_sqlite
Found 1 test(s).
System check identified no issues (0 silenced).
E
======================================================================
ERROR: messages_tests (unittest.loader._FailedTest)
----------------------------------------------------------------------
ImportError: Failed to import test module: messages_tests
Traceback (most recent call last):
  File "/opt/miniconda3/envs/testbed/lib/python3.9/unittest/loader.py", line 154, in loadTestsFromName
    module = __import__(module_name)
ModuleNotFoundError: No module named 'messages_tests'


----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (errors=1)
--------------------------------------------------------------------------------
18: Let's try a different approach:
>> cd /testbed && python tests/runtests.py messages_tests
Testing against Django installed in '/testbed/django' with up to 8 processes
Found 96 test(s).
Creating test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
System check identified no issues (0 silenced).
................................................................................................
----------------------------------------------------------------------
Ran 96 tests in 0.239s

OK
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
--------------------------------------------------------------------------------
19: Great! All the existing message tests are passing. Now let's think about potential edge cases and performance implications:

1. **Performance**: Our change means that `utils.get_level_tags()` will be called every time `level_tag` is accessed instead of using a cached value. Let's check if this could be a performance issue.
>> str_replace_editor view /testbed/django/contrib/messages/utils.py
Here's the result of running `cat -n` on /testbed/django/contrib/messages/utils.py:
     1	from django.conf import settings
     2	from django.contrib.messages import constants
     3	
     4	
     5	def get_level_tags():
     6	    """
     7	    Return the message level tags.
     8	    """
     9	    return {
    10	        **constants.DEFAULT_TAGS,
    11	        **getattr(settings, 'MESSAGE_TAGS', {}),
    12	    }
    13
--------------------------------------------------------------------------------
20: The `get_level_tags()` function is very simple - it just merges two dictionaries. This is a fast operation and shouldn't cause performance issues. The `getattr(settings, 'MESSAGE_TAGS', {})` call is also fast since Django's settings are cached.

2. **Thread safety**: Since we're now reading from settings each time, we need to make sure this is thread-safe. Django's settings are thread-safe, so this should be fine.

3. **Backward compatibility**: Our change doesn't break the API - the `level_tag` property still works the same way from the outside.

Let's also check if there are any other places in the codebase that might be using the `LEVEL_TAGS` constant directly:
>> cd /testbed && find . -name "*.py" -exec grep -l "LEVEL_TAGS" {} \;
./django/contrib/messages/storage/base.py
./test_comprehensive.py
./tests/messages_tests/base.py
./reproduce_issue.py
--------------------------------------------------------------------------------
21: Let's check the test base file to see how it uses `LEVEL_TAGS`:
>> cd /testbed && grep -n "LEVEL_TAGS" tests/messages_tests/base.py
28:        # LEVEL_TAGS is a constant defined in the
31:        self.old_level_tags = base.LEVEL_TAGS
32:        base.LEVEL_TAGS = utils.get_level_tags()
36:        base.LEVEL_TAGS = self.old_level_tags
--------------------------------------------------------------------------------
22: The test base file has a custom `override_settings_tags` class that manually updates `base.LEVEL_TAGS`. Since we've changed the implementation to not rely on the cached `LEVEL_TAGS` constant, this custom class is no longer needed for the fix, but it doesn't hurt to keep it for backward compatibility.

However, let's check if our change makes the `LEVEL_TAGS` constant unused. Looking at the base.py file:
>> str_replace_editor view /testbed/django/contrib/messages/storage/base.py  --view_range 1 10
Here's the result of running `cat -n` on /testbed/django/contrib/messages/storage/base.py:
     1	from django.conf import settings
     2	from django.contrib.messages import constants, utils
     3	
     4	LEVEL_TAGS = utils.get_level_tags()
     5	
     6	
     7	class Message:
     8	    """
     9	    Represent an actual message that can be stored in any of the supported
    10	    storage classes (typically session- or cookie-based) and rendered in a view
--------------------------------------------------------------------------------
23: The `LEVEL_TAGS` constant is still defined but no longer used by our code. We could remove it, but that might break backward compatibility if any third-party code is importing and using it. Let's keep it for now but add a comment explaining that it's deprecated.

Actually, let's check if the constant is used anywhere else in the Django codebase:
>> cd /testbed && grep -r "from.*base import.*LEVEL_TAGS" . --include="*.py"
./reproduce_issue.py:from django.contrib.messages.storage.base import Message, LEVEL_TAGS
--------------------------------------------------------------------------------
24: 
>> cd /testbed && grep -r "base\.LEVEL_TAGS" . --include="*.py"
./tests/messages_tests/base.py:        self.old_level_tags = base.LEVEL_TAGS
./tests/messages_tests/base.py:        base.LEVEL_TAGS = utils.get_level_tags()
./tests/messages_tests/base.py:        base.LEVEL_TAGS = self.old_level_tags
--------------------------------------------------------------------------------
25: The `LEVEL_TAGS` constant is only used in the test base file and our test scripts. Since it's part of the public API (it's importable), we should keep it for backward compatibility, but we can add a deprecation comment.

Let's add a comment to indicate that the constant is deprecated:
>> str_replace_editor str_replace /testbed/django/contrib/messages/storage/base.py   --old_str 'from django.conf import settings
The file /testbed/django/contrib/messages/storage/base.py has been edited. Here's the result of running `cat -n` on a snippet of /testbed/django/contrib/messages/storage/base.py:
     1	from django.conf import settings
     2	from django.contrib.messages import constants, utils
     3	
     4	# LEVEL_TAGS is kept for backward compatibility but is no longer used internally.
     5	# The level_tag property now calls utils.get_level_tags() directly to ensure
     6	# it reflects the current MESSAGE_TAGS setting.
     7	LEVEL_TAGS = utils.get_level_tags()
     8	
     9	
    10	class Message:
Review the changes and make sure they are as expected. Edit the file again if necessary.
--------------------------------------------------------------------------------
26: Now let's run our tests again to make sure everything still works:
>> cd /testbed && python test_comprehensive.py
=== Comprehensive LEVEL_TAGS test ===

1. Testing default tags:
INFO level_tag: 'info'
WARNING level_tag: 'warning'

2. Testing custom level without override:
Custom level 35 level_tag: ''

3. Testing custom level with override:
Custom level 35 level_tag: 'custom'
New custom message level_tag: 'custom'
INFO level_tag inside override: 'info'

4. Testing after override:
Custom level 35 level_tag: ''
INFO level_tag after override: 'info'

5. Testing override of existing default tag:
INFO level_tag with override: 'information'
INFO level_tag after override: 'info'

6. Testing multiple custom tags:
Level 35 level_tag: 'custom1'
Level 45 level_tag: 'custom2'

7. Testing tags property:
Error message tags: 'urgent error'
Error message tags with override: 'urgent danger'

=== All tests completed ===
--------------------------------------------------------------------------------
27: 
>> cd /testbed && python tests/runtests.py messages_tests
Testing against Django installed in '/testbed/django' with up to 8 processes
Found 96 test(s).
Creating test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
System check identified no issues (0 silenced).
................................................................................................
----------------------------------------------------------------------
Ran 96 tests in 0.144s

OK
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
--------------------------------------------------------------------------------
28: Perfect! All tests are still passing. Let's also create a test that specifically demonstrates the fix for the issue described in the PR:
>> str_replace_editor create /testbed/test_pr_issue.py --file_text '#!/usr/bin/env python
File created successfully at: /testbed/test_pr_issue.py
--------------------------------------------------------------------------------
29: 
>> cd /testbed && python test_pr_issue.py
=== Testing PR Issue: LEVEL_TAGS not updated when using @override_settings ===
Before @override_settings:
  Message level: 35
  Message level_tag: '' (should be empty)

Inside @override_settings(MESSAGE_TAGS={35: 'custom-level'}):
  Message level_tag: 'custom-level' (should be 'custom-level')
  Message tags: 'custom-level' (should be 'custom-level')
  Message with extra tags: 'urgent custom-level' (should be 'urgent custom-level')

After @override_settings:
  Message level_tag: '' (should be empty again)

 PR Issue test passed! The level_tag property now correctly reflects MESSAGE_TAGS changes.
--------------------------------------------------------------------------------
30: Excellent! Our fix is working perfectly. Let's also test that it works with the existing Django test infrastructure by running a specific test that uses the custom `override_settings_tags`:
>> cd /testbed && python tests/runtests.py messages_tests.test_api.ApiTests.test_custom_tags
Testing against Django installed in '/testbed/django' with up to 8 processes
Found 1 test(s).
System check identified no issues (0 silenced).
E
======================================================================
ERROR: test_custom_tags (unittest.loader._FailedTest)
----------------------------------------------------------------------
AttributeError: type object 'ApiTests' has no attribute 'test_custom_tags'

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (errors=1)
--------------------------------------------------------------------------------
31: Let's find the correct test:
>> cd /testbed && grep -r "test_custom_tags" tests/messages_tests/
tests/messages_tests/base.py:    def test_custom_tags(self):
grep: tests/messages_tests/__pycache__/base.cpython-39.pyc: binary file matches
--------------------------------------------------------------------------------
32: 
>> cd /testbed && python tests/runtests.py messages_tests.test_session.SessionTests.test_custom_tags
Testing against Django installed in '/testbed/django' with up to 8 processes
Found 1 test(s).
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
.
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
Destroying test database for alias 'default'...
--------------------------------------------------------------------------------
33: Great! The existing test that uses custom tags is still passing.

Now let's also test some edge cases to make sure our fix is robust:
>> str_replace_editor create /testbed/test_edge_cases.py --file_text '#!/usr/bin/env python
File created successfully at: /testbed/test_edge_cases.py
--------------------------------------------------------------------------------
34: 
>> cd /testbed && python test_edge_cases.py
=== Testing Edge Cases ===

1. Testing empty MESSAGE_TAGS override:
  Before override: 'info'
  With empty MESSAGE_TAGS: 'info'

2. Testing None values in MESSAGE_TAGS:
  With None value: 'None'

3. Testing empty string values in MESSAGE_TAGS:
  With empty string: ''

4. Testing nested overrides:
  Outer override: 'outer'
  Inner override: 'inner'
  Back to outer: 'outer'
  Back to default: 'info'

5. Testing very large level numbers:
  Large level without override: ''
  Large level with override: 'huge'

6. Testing negative level numbers:
  Negative level without override: ''
  Negative level with override: 'negative'

7. Testing Unicode tags:
  Unicode tag: ''

 All edge cases passed!
--------------------------------------------------------------------------------
35: Perfect! Our fix handles all the edge cases correctly.

Let's also run a broader set of tests to make sure we didn't break anything else:
>> cd /testbed && python tests/runtests.py auth_tests.test_decorators settings_tests --parallel 1
Testing against Django installed in '/testbed/django'
Found 65 test(s).
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
.................................................................
----------------------------------------------------------------------
Ran 65 tests in 0.062s

OK
Destroying test database for alias 'default'...
--------------------------------------------------------------------------------
36: Great! Let's also test some template-related functionality to make sure the `tags` property works correctly in templates:
>> str_replace_editor create /testbed/test_template_integration.py --file_text '#!/usr/bin/env python
File created successfully at: /testbed/test_template_integration.py
--------------------------------------------------------------------------------
37: 
>> cd /testbed && python test_template_integration.py
=== Testing Template Integration ===
Traceback (most recent call last):
  File "/testbed/django/template/base.py", line 500, in parse
    compile_func = self.tags[command]
KeyError: '-'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/testbed/test_template_integration.py", line 80, in <module>
    test_template_integration()
  File "/testbed/test_template_integration.py", line 46, in test_template_integration
    template = Template(template_str)
  File "/testbed/django/template/base.py", line 155, in __init__
    self.nodelist = self.compile_nodelist()
  File "/testbed/django/template/base.py", line 199, in compile_nodelist
    return parser.parse()
  File "/testbed/django/template/base.py", line 502, in parse
    self.invalid_block_tag(token, command, parse_until)
  File "/testbed/django/template/base.py", line 561, in invalid_block_tag
    raise self.error(
django.template.exceptions.TemplateSyntaxError: Invalid block tag on line 2: '-'. Did you forget to register or load this tag?
--------------------------------------------------------------------------------
38: Let me fix the template syntax:
>> str_replace_editor str_replace /testbed/test_template_integration.py   --old_str '    # Create a simple template that uses message tags
The file /testbed/test_template_integration.py has been edited. Here's the result of running `cat -n` on a snippet of /testbed/test_template_integration.py:
    34	from django.test import override_settings
    35	
    36	def test_template_integration():
    37	    print("=== Testing Template Integration ===")
    38	    
    39	    # Create a simple template that uses message tags
    40	    template_str = """{% for message in messages %}{{ message.level_tag }}|{{ message.tags }}{% if not forloop.last %};{% endif %}{% endfor %}"""
    41	    
    42	    template = Template(template_str)
    43	    
Review the changes and make sure they are as expected. Edit the file again if necessary.
--------------------------------------------------------------------------------
39: 
>> str_replace_editor str_replace /testbed/test_template_integration.py   --old_str '    print("\n1. Testing with default tags:")
The file /testbed/test_template_integration.py has been edited. Here's the result of running `cat -n` on a snippet of /testbed/test_template_integration.py:
    46	        Message(constants.INFO, "Info message"),
    47	        Message(35, "Custom level message"),
    48	        Message(constants.ERROR, "Error message", extra_tags="urgent"),
    49	    ]
    50	    
    51	    print("\n1. Testing with default tags:")
    52	    context = Context({'messages': messages})
    53	    result = template.render(context)
    54	    print(f"  Template result: '{result}'")
    55	    expected = "info|info;|;error|urgent error"
    56	    assert result == expected, f"Expected '{expected}', got '{result}'"
    57	    
    58	    print("\n2. Testing with custom MESSAGE_TAGS:")
    59	    with override_settings(MESSAGE_TAGS={35: 'custom', constants.ERROR: 'danger'}):
    60	        context = Context({'messages': messages})
    61	        result = template.render(context)
    62	        print(f"  Template result: '{result}'")
    63	        expected = "info|info;custom|custom;danger|urgent danger"
    64	        assert result == expected, f"Expected '{expected}', got '{result}'"
    65	    
    66	    print("\n3. Testing back to default:")
    67	    context = Context({'messages': messages})
    68	    result = template.render(context)
    69	    print(f"  Template result: '{result}'")
    70	    expected = "info|info;|;error|urgent error"
    71	    assert result == expected, f"Expected '{expected}', got '{result}'"
    72	    
    73	    print("\n Template integration test passed!")
    74	
Review the changes and make sure they are as expected. Edit the file again if necessary.
--------------------------------------------------------------------------------
40: 
>> cd /testbed && python test_template_integration.py
=== Testing Template Integration ===

1. Testing with default tags:
  Template result: 'info|info;|;error|urgent error'

2. Testing with custom MESSAGE_TAGS:
  Template result: 'info|info;custom|custom;danger|urgent danger'

3. Testing back to default:
  Template result: 'info|info;|;error|urgent error'

 Template integration test passed!
--------------------------------------------------------------------------------
41: Excellent! Our fix works correctly in templates as well.

Now let's create one final test to verify that the fix works in a real Django test environment using the standard `@override_settings` decorator:
>> str_replace_editor create /testbed/test_django_test_case.py --file_text '#!/usr/bin/env python
File created successfully at: /testbed/test_django_test_case.py
--------------------------------------------------------------------------------
42: 
>> cd /testbed && python test_django_test_case.py
...
----------------------------------------------------------------------
Ran 3 tests in 0.010s

OK
--------------------------------------------------------------------------------
43: Perfect! All tests pass, confirming that our fix works correctly with Django's standard test infrastructure.

## Summary

I have successfully implemented a fix for the issue described in the PR: "LEVEL_TAGS not updated when using @override_settings". Here's what I did:

### Problem Analysis
The issue was that the `LEVEL_TAGS` constant in `/testbed/django/contrib/messages/storage/base.py` was being evaluated at module import time, capturing the `MESSAGE_TAGS` setting value at that moment. When tests used `@override_settings` to change `MESSAGE_TAGS`, the `LEVEL_TAGS` constant was not updated, causing the `Message.level_tag` property to return empty strings instead of the custom tags.

### Solution
I modified the `level_tag` property in the `Message` class to call `utils.get_level_tags()` directly instead of using the cached `LEVEL_TAGS` constant. This ensures that the property always reflects the current `MESSAGE_TAGS` setting.

### Changes Made
1. **Modified `/testbed/django/contrib/messages/storage/base.py`**:
   - Changed the `level_tag` property to use `utils.get_level_tags().get(self.level, '')` instead of `LEVEL_TAGS.get(self.level, '')`
   - Added a comment explaining that `LEVEL_TAGS` is kept for backward compatibility but is no longer used internally

### Key Benefits
1. **Fixes the reported issue**: `@override_settings` now correctly updates message tags
2. **Maintains backward compatibility**: The `LEVEL_TAGS` constant is still available for any code that might import it
3. **No performance impact**: The `get_level_tags()` function is very lightweight (just merging two dictionaries)
4. **Thread-safe**: Django's settings are thread-safe, so this approach is safe for concurrent access
5. **Works with all Django test infrastructure**: Compatible with both context manager and decorator forms of `@override_settings`

### Testing
I thoroughly tested the fix with:
1. **Reproduction script**: Confirmed the issue existed and was fixed
2. **Comprehensive tests**: Verified all edge cases work correctly
3. **Django test suite**: All existing message tests still pass (96 tests)
4. **Template integration**: Confirmed the fix works in Django templates
5. **Real Django test cases**: Verified the fix works with Django's `TestCase` class

The fix is minimal, focused, and addresses the exact issue described in the PR without breaking any existing functionality.
>> submit
Thank you for your work on this issue. Please carefully follow the steps below to help review your changes.

1. If you made any changes to your code after running the reproduction script, please run the reproduction script again.
  If the reproduction script is failing, please revisit your changes and make sure they are correct.
  If you have already removed your reproduction script, please ignore this step.
2. Remove your reproduction script (if you haven't done so already).
3. If you have modified any TEST files, please revert them to the state they had before you started fixing the issue.
  You can do this with `git checkout -- /path/to/test/file.py`. Use below <diff> to find the files you need to revert.
4. Run the submit command again to confirm.

Here is a list of all of your changes:

<diff>
diff --git a/django/contrib/messages/storage/base.py b/django/contrib/messages/storage/base.py
index 01422066a6..23752bdfeb 100644
--- a/django/contrib/messages/storage/base.py
+++ b/django/contrib/messages/storage/base.py
@@ -1,6 +1,9 @@
 from django.conf import settings
 from django.contrib.messages import constants, utils
 
+# LEVEL_TAGS is kept for backward compatibility but is no longer used internally.
+# The level_tag property now calls utils.get_level_tags() directly to ensure
+# it reflects the current MESSAGE_TAGS setting.
 LEVEL_TAGS = utils.get_level_tags()
 
 
@@ -38,7 +41,7 @@ class Message:
 
     @property
     def level_tag(self):
-        return LEVEL_TAGS.get(self.level, '')
+        return utils.get_level_tags().get(self.level, '')
 
 
 class BaseStorage:
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..dd655d5a90
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python
+"""
+Script to reproduce the LEVEL_TAGS issue with @override_settings
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+# Create a minimal settings module
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.messages',
+        ],
+        MESSAGE_TAGS={},
+    )
+
+django.setup()
+
+from django.contrib.messages import constants
+from django.contrib.messages.storage.base import Message, LEVEL_TAGS
+from django.test import override_settings
+
+def test_level_tags_issue():
+    print("=== Testing LEVEL_TAGS issue ===")
+    
+    # Create a message with a custom level
+    custom_level = 35
+    message = Message(custom_level, "Test message")
+    
+    print(f"Initial LEVEL_TAGS: {LEVEL_TAGS}")
+    print(f"Message level: {message.level}")
+    print(f"Message level_tag (before override): '{message.level_tag}'")
+    
+    # Now override settings to add a custom tag for level 35
+    with override_settings(MESSAGE_TAGS={35: 'custom'}):
+        print(f"LEVEL_TAGS inside override_settings: {LEVEL_TAGS}")
+        print(f"Message level_tag (inside override): '{message.level_tag}'")
+        
+        # Create a new message inside the override
+        new_message = Message(custom_level, "New test message")
+        print(f"New message level_tag (inside override): '{new_message.level_tag}'")
+    
+    print(f"LEVEL_TAGS after override_settings: {LEVEL_TAGS}")
+    print(f"Message level_tag (after override): '{message.level_tag}'")
+
+if __name__ == '__main__':
+    test_level_tags_issue()
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..28bcba5fc7
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python
+"""
+Comprehensive test for the LEVEL_TAGS fix
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.messages',
+        ],
+        MESSAGE_TAGS={},
+    )
+
+django.setup()
+
+from django.contrib.messages import constants
+from django.contrib.messages.storage.base import Message
+from django.test import override_settings
+
+def test_comprehensive():
+    print("=== Comprehensive LEVEL_TAGS test ===")
+    
+    # Test 1: Default tags work
+    print("\n1. Testing default tags:")
+    msg_info = Message(constants.INFO, "Info message")
+    msg_warning = Message(constants.WARNING, "Warning message")
+    print(f"INFO level_tag: '{msg_info.level_tag}'")
+    print(f"WARNING level_tag: '{msg_warning.level_tag}'")
+    
+    # Test 2: Custom level without override (should be empty)
+    print("\n2. Testing custom level without override:")
+    custom_level = 35
+    msg_custom = Message(custom_level, "Custom message")
+    print(f"Custom level {custom_level} level_tag: '{msg_custom.level_tag}'")
+    
+    # Test 3: Custom level with override
+    print("\n3. Testing custom level with override:")
+    with override_settings(MESSAGE_TAGS={35: 'custom'}):
+        print(f"Custom level {custom_level} level_tag: '{msg_custom.level_tag}'")
+        
+        # Create new message inside override
+        new_msg = Message(custom_level, "New custom message")
+        print(f"New custom message level_tag: '{new_msg.level_tag}'")
+        
+        # Test existing default levels still work
+        print(f"INFO level_tag inside override: '{msg_info.level_tag}'")
+    
+    # Test 4: After override, custom tag should be gone
+    print("\n4. Testing after override:")
+    print(f"Custom level {custom_level} level_tag: '{msg_custom.level_tag}'")
+    print(f"INFO level_tag after override: '{msg_info.level_tag}'")
+    
+    # Test 5: Override existing default tag
+    print("\n5. Testing override of existing default tag:")
+    with override_settings(MESSAGE_TAGS={constants.INFO: 'information'}):
+        print(f"INFO level_tag with override: '{msg_info.level_tag}'")
+    print(f"INFO level_tag after override: '{msg_info.level_tag}'")
+    
+    # Test 6: Multiple custom tags
+    print("\n6. Testing multiple custom tags:")
+    msg_custom2 = Message(45, "Another custom message")
+    with override_settings(MESSAGE_TAGS={35: 'custom1', 45: 'custom2'}):
+        print(f"Level 35 level_tag: '{msg_custom.level_tag}'")
+        print(f"Level 45 level_tag: '{msg_custom2.level_tag}'")
+    
+    # Test 7: Test tags property (which uses level_tag)
+    print("\n7. Testing tags property:")
+    msg_with_extra = Message(constants.ERROR, "Error with extra", extra_tags="urgent")
+    print(f"Error message tags: '{msg_with_extra.tags}'")
+    
+    with override_settings(MESSAGE_TAGS={constants.ERROR: 'danger'}):
+        print(f"Error message tags with override: '{msg_with_extra.tags}'")
+    
+    print("\n=== All tests completed ===")
+
+if __name__ == '__main__':
+    test_comprehensive()
\ No newline at end of file
diff --git a/test_django_test_case.py b/test_django_test_case.py
new file mode 100644
index 0000000000..ff01ada913
--- /dev/null
+++ b/test_django_test_case.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python
+"""
+Test the fix using Django's TestCase with @override_settings
+"""
+import os
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.messages',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        MESSAGE_TAGS={},
+    )
+
+django.setup()
+
+from django.contrib.messages import constants
+from django.contrib.messages.storage.base import Message
+from django.test import TestCase, override_settings
+
+class MessageLevelTagsTest(TestCase):
+    """Test that @override_settings correctly updates MESSAGE_TAGS for level_tag property."""
+    
+    def test_level_tag_with_override_settings(self):
+        """Test that level_tag property reflects MESSAGE_TAGS changes with @override_settings."""
+        # Create a message with a custom level
+        custom_level = 35
+        message = Message(custom_level, "Test message")
+        
+        # Initially, custom level should have no tag
+        self.assertEqual(message.level_tag, '')
+        
+        # Use @override_settings to add a custom tag
+        with override_settings(MESSAGE_TAGS={35: 'custom-level'}):
+            # Now the level_tag should return the custom tag
+            self.assertEqual(message.level_tag, 'custom-level')
+            
+            # Test that tags property also works
+            self.assertEqual(message.tags, 'custom-level')
+            
+            # Test with extra tags
+            message_with_extra = Message(custom_level, "Test", extra_tags="urgent")
+            self.assertEqual(message_with_extra.tags, 'urgent custom-level')
+        
+        # After the override, it should be empty again
+        self.assertEqual(message.level_tag, '')
+    
+    @override_settings(MESSAGE_TAGS={constants.INFO: 'information', 50: 'critical'})
+    def test_level_tag_with_decorator_override(self):
+        """Test that @override_settings decorator also works correctly."""
+        # Test overriding existing default tag
+        info_message = Message(constants.INFO, "Info message")
+        self.assertEqual(info_message.level_tag, 'information')
+        
+        # Test custom level
+        critical_message = Message(50, "Critical message")
+        self.assertEqual(critical_message.level_tag, 'critical')
+    
+    def test_level_tag_default_behavior(self):
+        """Test that default behavior still works."""
+        # Test default tags
+        info_message = Message(constants.INFO, "Info")
+        warning_message = Message(constants.WARNING, "Warning")
+        
+        self.assertEqual(info_message.level_tag, 'info')
+        self.assertEqual(warning_message.level_tag, 'warning')
+        
+        # Test unknown level
+        unknown_message = Message(999, "Unknown")
+        self.assertEqual(unknown_message.level_tag, '')
+
+if __name__ == '__main__':
+    import unittest
+    unittest.main()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..fe407610f1
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,98 @@
+#!/usr/bin/env python
+"""
+Test edge cases for the LEVEL_TAGS fix
+"""
+import os
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.messages',
+        ],
+        MESSAGE_TAGS={},
+    )
+
+django.setup()
+
+from django.contrib.messages import constants
+from django.contrib.messages.storage.base import Message
+from django.test import override_settings
+
+def test_edge_cases():
+    print("=== Testing Edge Cases ===")
+    
+    # Test 1: Empty MESSAGE_TAGS override
+    print("\n1. Testing empty MESSAGE_TAGS override:")
+    msg = Message(constants.INFO, "Test message")
+    print(f"  Before override: '{msg.level_tag}'")
+    
+    with override_settings(MESSAGE_TAGS={}):
+        print(f"  With empty MESSAGE_TAGS: '{msg.level_tag}'")
+        # Should still work with default tags
+        assert msg.level_tag == 'info'
+    
+    # Test 2: None values in MESSAGE_TAGS
+    print("\n2. Testing None values in MESSAGE_TAGS:")
+    with override_settings(MESSAGE_TAGS={constants.INFO: None}):
+        print(f"  With None value: '{msg.level_tag}'")
+        # None should be treated as a valid tag
+        assert msg.level_tag is None
+    
+    # Test 3: Empty string values in MESSAGE_TAGS
+    print("\n3. Testing empty string values in MESSAGE_TAGS:")
+    with override_settings(MESSAGE_TAGS={constants.INFO: ''}):
+        print(f"  With empty string: '{msg.level_tag}'")
+        assert msg.level_tag == ''
+    
+    # Test 4: Nested overrides
+    print("\n4. Testing nested overrides:")
+    with override_settings(MESSAGE_TAGS={constants.INFO: 'outer'}):
+        print(f"  Outer override: '{msg.level_tag}'")
+        assert msg.level_tag == 'outer'
+        
+        with override_settings(MESSAGE_TAGS={constants.INFO: 'inner'}):
+            print(f"  Inner override: '{msg.level_tag}'")
+            assert msg.level_tag == 'inner'
+        
+        print(f"  Back to outer: '{msg.level_tag}'")
+        assert msg.level_tag == 'outer'
+    
+    print(f"  Back to default: '{msg.level_tag}'")
+    assert msg.level_tag == 'info'
+    
+    # Test 5: Very large level numbers
+    print("\n5. Testing very large level numbers:")
+    large_level = 999999
+    msg_large = Message(large_level, "Large level message")
+    print(f"  Large level without override: '{msg_large.level_tag}'")
+    assert msg_large.level_tag == ''
+    
+    with override_settings(MESSAGE_TAGS={large_level: 'huge'}):
+        print(f"  Large level with override: '{msg_large.level_tag}'")
+        assert msg_large.level_tag == 'huge'
+    
+    # Test 6: Negative level numbers
+    print("\n6. Testing negative level numbers:")
+    negative_level = -10
+    msg_negative = Message(negative_level, "Negative level message")
+    print(f"  Negative level without override: '{msg_negative.level_tag}'")
+    assert msg_negative.level_tag == ''
+    
+    with override_settings(MESSAGE_TAGS={negative_level: 'negative'}):
+        print(f"  Negative level with override: '{msg_negative.level_tag}'")
+        assert msg_negative.level_tag == 'negative'
+    
+    # Test 7: Unicode tags
+    print("\n7. Testing Unicode tags:")
+    with override_settings(MESSAGE_TAGS={constants.INFO: ''}):
+        print(f"  Unicode tag: '{msg.level_tag}'")
+        assert msg.level_tag == ''
+    
+    print("\n All edge cases passed!")
+
+if __name__ == '__main__':
+    test_edge_cases()
\ No newline at end of file
diff --git a/test_pr_issue.py b/test_pr_issue.py
new file mode 100644
index 0000000000..82d32b6fcd
--- /dev/null
+++ b/test_pr_issue.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python
+"""
+Test that specifically demonstrates the fix for the PR issue:
+"LEVEL_TAGS not updated when using @override_settings"
+"""
+import os
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.messages',
+        ],
+        MESSAGE_TAGS={},
+    )
+
+django.setup()
+
+from django.contrib.messages import constants
+from django.contrib.messages.storage.base import Message
+from django.test import override_settings
+
+def test_pr_issue():
+    """
+    Test that demonstrates the issue described in the PR and verifies the fix.
+    
+    The issue: When reading messages inside tests, new message tags created 
+    using @override_settings is not updated. That causes the 
+    django.contrib.messages.storage.base.Message.level_tag property 
+    results to be an empty string and not know the new tags.
+    """
+    print("=== Testing PR Issue: LEVEL_TAGS not updated when using @override_settings ===")
+    
+    # Create a message with a custom level that doesn't have a default tag
+    custom_level = 35
+    message = Message(custom_level, "Test message with custom level")
+    
+    print(f"Before @override_settings:")
+    print(f"  Message level: {message.level}")
+    print(f"  Message level_tag: '{message.level_tag}' (should be empty)")
+    
+    # This should be empty since level 35 doesn't have a default tag
+    assert message.level_tag == '', f"Expected empty string, got '{message.level_tag}'"
+    
+    # Now use @override_settings to add a custom tag for this level
+    with override_settings(MESSAGE_TAGS={35: 'custom-level'}):
+        print(f"\nInside @override_settings(MESSAGE_TAGS={{35: 'custom-level'}}):")
+        print(f"  Message level_tag: '{message.level_tag}' (should be 'custom-level')")
+        
+        # This should now return 'custom-level' instead of empty string
+        assert message.level_tag == 'custom-level', f"Expected 'custom-level', got '{message.level_tag}'"
+        
+        # Test that the tags property also works correctly
+        print(f"  Message tags: '{message.tags}' (should be 'custom-level')")
+        assert message.tags == 'custom-level', f"Expected 'custom-level', got '{message.tags}'"
+        
+        # Test with extra tags
+        message_with_extra = Message(custom_level, "Test with extra", extra_tags="urgent")
+        print(f"  Message with extra tags: '{message_with_extra.tags}' (should be 'urgent custom-level')")
+        assert message_with_extra.tags == 'urgent custom-level', f"Expected 'urgent custom-level', got '{message_with_extra.tags}'"
+    
+    print(f"\nAfter @override_settings:")
+    print(f"  Message level_tag: '{message.level_tag}' (should be empty again)")
+    
+    # After the override, it should be empty again
+    assert message.level_tag == '', f"Expected empty string, got '{message.level_tag}'"
+    
+    print("\n PR Issue test passed! The level_tag property now correctly reflects MESSAGE_TAGS changes.")
+
+if __name__ == '__main__':
+    test_pr_issue()
\ No newline at end of file
diff --git a/test_template_integration.py b/test_template_integration.py
new file mode 100644
index 0000000000..b920915c22
--- /dev/null
+++ b/test_template_integration.py
@@ -0,0 +1,76 @@
+#!/usr/bin/env python
+"""
+Test template integration for the LEVEL_TAGS fix
+"""
+import os
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.messages',
+        ],
+        TEMPLATES=[{
+            'BACKEND': 'django.template.backends.django.DjangoTemplates',
+            'DIRS': [],
+            'APP_DIRS': True,
+            'OPTIONS': {
+                'context_processors': [
+                    'django.contrib.messages.context_processors.messages',
+                ],
+            },
+        }],
+        MESSAGE_TAGS={},
+    )
+
+django.setup()
+
+from django.contrib.messages import constants
+from django.contrib.messages.storage.base import Message
+from django.template import Context, Template
+from django.test import override_settings
+
+def test_template_integration():
+    print("=== Testing Template Integration ===")
+    
+    # Create a simple template that uses message tags
+    template_str = """{% for message in messages %}{{ message.level_tag }}|{{ message.tags }}{% if not forloop.last %};{% endif %}{% endfor %}"""
+    
+    template = Template(template_str)
+    
+    # Create some messages
+    messages = [
+        Message(constants.INFO, "Info message"),
+        Message(35, "Custom level message"),
+        Message(constants.ERROR, "Error message", extra_tags="urgent"),
+    ]
+    
+    print("\n1. Testing with default tags:")
+    context = Context({'messages': messages})
+    result = template.render(context)
+    print(f"  Template result: '{result}'")
+    expected = "info|info;|;error|urgent error"
+    assert result == expected, f"Expected '{expected}', got '{result}'"
+    
+    print("\n2. Testing with custom MESSAGE_TAGS:")
+    with override_settings(MESSAGE_TAGS={35: 'custom', constants.ERROR: 'danger'}):
+        context = Context({'messages': messages})
+        result = template.render(context)
+        print(f"  Template result: '{result}'")
+        expected = "info|info;custom|custom;danger|urgent danger"
+        assert result == expected, f"Expected '{expected}', got '{result}'"
+    
+    print("\n3. Testing back to default:")
+    context = Context({'messages': messages})
+    result = template.render(context)
+    print(f"  Template result: '{result}'")
+    expected = "info|info;|;error|urgent error"
+    assert result == expected, f"Expected '{expected}', got '{result}'"
+    
+    print("\n Template integration test passed!")
+
+if __name__ == '__main__':
+    test_template_integration()
\ No newline at end of file

</diff>
--------------------------------------------------------------------------------
44: Let me run the reproduction script one more time to confirm the fix is working, then remove the test files:
>> cd /testbed && python reproduce_issue.py
=== Testing LEVEL_TAGS issue ===
Initial LEVEL_TAGS: {10: 'debug', 20: 'info', 25: 'success', 30: 'warning', 40: 'error'}
Message level: 35
Message level_tag (before override): ''
LEVEL_TAGS inside override_settings: {10: 'debug', 20: 'info', 25: 'success', 30: 'warning', 40: 'error'}
Message level_tag (inside override): 'custom'
New message level_tag (inside override): 'custom'
LEVEL_TAGS after override_settings: {10: 'debug', 20: 'info', 25: 'success', 30: 'warning', 40: 'error'}
Message level_tag (after override): ''
--------------------------------------------------------------------------------
45: Perfect! The fix is working correctly. Now let me remove all the test files:
>> cd /testbed && rm reproduce_issue.py test_comprehensive.py test_django_test_case.py test_edge_cases.py test_pr_issue.py test_template_integration.py

--------------------------------------------------------------------------------
46: Let me verify that no test files were modified (there shouldn't be any since I was told not to modify test files):
>> cd /testbed && git status
HEAD detached at 9a6e2df3a8
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   django/contrib/messages/storage/base.py
--------------------------------------------------------------------------------
47: Perfect! Only the necessary file was modified. Let me run the Django message tests one more time to confirm everything is working:
>> cd /testbed && python tests/runtests.py messages_tests
Testing against Django installed in '/testbed/django' with up to 8 processes
Found 96 test(s).
Creating test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
Cloning test database for alias 'default'...
System check identified no issues (0 silenced).
................................................................................................
----------------------------------------------------------------------
Ran 96 tests in 0.143s

OK
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
Destroying test database for alias 'default'...
--------------------------------------------------------------------------------
48: Excellent! All tests are passing. 
>> submit
diff --git a/django/contrib/messages/storage/base.py b/django/contrib/messages/storage/base.py
index 01422066a6..23752bdfeb 100644
--- a/django/contrib/messages/storage/base.py
+++ b/django/contrib/messages/storage/base.py
@@ -1,6 +1,9 @@
 from django.conf import settings
 from django.contrib.messages import constants, utils
 
+# LEVEL_TAGS is kept for backward compatibility but is no longer used internally.
+# The level_tag property now calls utils.get_level_tags() directly to ensure
+# it reflects the current MESSAGE_TAGS setting.
 LEVEL_TAGS = utils.get_level_tags()
 
 
@@ -38,7 +41,7 @@ class Message:
 
     @property
     def level_tag(self):
-        return LEVEL_TAGS.get(self.level, '')
+        return utils.get_level_tags().get(self.level, '')
 
 
 class BaseStorage:

--------------------------------------------------------------------------------
Finished in 48 steps
