{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "sympy__sympy-24066", "model_patch": "diff --git a/sympy/physics/units/unitsystem.py b/sympy/physics/units/unitsystem.py\nindex 3daf84c108..563db7323d 100644\n--- a/sympy/physics/units/unitsystem.py\n+++ b/sympy/physics/units/unitsystem.py\n@@ -192,8 +192,61 @@ def _collect_factor_and_dimension(self, expr):\n         elif isinstance(expr, Function):\n             fds = [self._collect_factor_and_dimension(\n                 arg) for arg in expr.args]\n-            return (expr.func(*(f[0] for f in fds)),\n-                    *(d[1] for d in fds))\n+            factors = [f[0] for f in fds]\n+            dimensions = [d[1] for d in fds]\n+            \n+            # For most mathematical functions, if all arguments are dimensionless,\n+            # the result should be dimensionless\n+            from sympy.functions.elementary.exponential import ExpBase, log\n+            from sympy.functions.elementary.trigonometric import TrigonometricFunction, InverseTrigonometricFunction\n+            from sympy.functions.elementary.hyperbolic import HyperbolicFunction, InverseHyperbolicFunction\n+            from sympy.functions.elementary.miscellaneous import sqrt\n+            from sympy.functions.elementary.complexes import Abs, re, im, arg, conjugate\n+            \n+            # Check if this is a function that should return dimensionless result\n+            # when given dimensionless arguments\n+            dimensionless_functions = (\n+                ExpBase,  # exp, exp_polar\n+                TrigonometricFunction,  # sin, cos, tan, sec, csc, cot, sinc\n+                InverseTrigonometricFunction,  # asin, acos, atan, asec, acsc, acot\n+                HyperbolicFunction,  # sinh, cosh, tanh, coth, sech, csch\n+                InverseHyperbolicFunction,  # asinh, acosh, atanh, acoth, asech, acsch\n+            )\n+            \n+            # Special case: log always returns dimensionless\n+            if isinstance(expr, log):\n+                return expr.func(*factors), Dimension(1)\n+            \n+            # For dimensionless functions, check if all arguments are dimensionless\n+            if isinstance(expr, dimensionless_functions):\n+                if all(self.get_dimension_system().is_dimensionless(d) for d in dimensions):\n+                    return expr.func(*factors), Dimension(1)\n+                else:\n+                    # If arguments are not dimensionless, this is an error for most functions\n+                    # But we'll let it pass through for now and let other validation catch it\n+                    pass\n+            \n+            # For functions like Abs, re, im, the result has the same dimension as the argument\n+            if isinstance(expr, (Abs, re, im)):\n+                if len(dimensions) == 1:\n+                    return expr.func(*factors), dimensions[0]\n+            \n+            # For sqrt and other power-like functions\n+            if expr.func == sqrt:\n+                if len(dimensions) == 1:\n+                    return expr.func(*factors), dimensions[0] ** S.Half\n+            \n+            # Default case: if we don't know how to handle this function,\n+            # we'll assume it preserves the dimension of its first argument\n+            # This is a fallback that may not be correct for all functions\n+            if len(dimensions) == 1:\n+                return expr.func(*factors), dimensions[0]\n+            elif len(dimensions) == 0:\n+                return expr.func(*factors), Dimension(1)\n+            else:\n+                # Multiple arguments - this is complex, for now return the first dimension\n+                # This may need more sophisticated handling for specific functions\n+                return expr.func(*factors), dimensions[0]\n         elif isinstance(expr, Dimension):\n             return S.One, expr\n         else:\n"}