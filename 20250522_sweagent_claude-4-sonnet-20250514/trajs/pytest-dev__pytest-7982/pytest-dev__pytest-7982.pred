{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "pytest-dev__pytest-7982", "model_patch": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex d8a208a1a..762b953cd 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -676,7 +676,11 @@ class Session(nodes.FSCollector):\n \n                 seen_dirs: Set[py.path.local] = set()\n                 for direntry in visit(str(argpath), self._recurse):\n-                    if not direntry.is_file():\n+                    try:\n+                        if not direntry.is_file():\n+                            continue\n+                    except OSError:\n+                        # Skip entries that can't be accessed (e.g., circular symlinks)\n                         continue\n \n                     path = py.path.local(direntry.path)\ndiff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex f0bdb1481..24bb4d507 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -558,8 +558,12 @@ def visit(\n     entries = sorted(os.scandir(path), key=lambda entry: entry.name)\n     yield from entries\n     for entry in entries:\n-        if entry.is_dir(follow_symlinks=False) and recurse(entry):\n-            yield from visit(entry.path, recurse)\n+        try:\n+            if entry.is_dir() and recurse(entry):\n+                yield from visit(entry.path, recurse)\n+        except OSError:\n+            # Skip entries that can't be accessed (e.g., circular symlinks)\n+            continue\n \n \n def absolutepath(path: Union[Path, str]) -> Path:\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 35797cc07..db61e6038 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -708,25 +708,29 @@ class Package(Module):\n         for direntry in visit(str(this_path), recurse=self._recurse):\n             path = py.path.local(direntry.path)\n \n-            # We will visit our own __init__.py file, in which case we skip it.\n-            if direntry.is_file():\n-                if direntry.name == \"__init__.py\" and path.dirpath() == this_path:\n+            try:\n+                # We will visit our own __init__.py file, in which case we skip it.\n+                if direntry.is_file():\n+                    if direntry.name == \"__init__.py\" and path.dirpath() == this_path:\n+                        continue\n+\n+                parts_ = parts(direntry.path)\n+                if any(\n+                    str(pkg_prefix) in parts_ and pkg_prefix.join(\"__init__.py\") != path\n+                    for pkg_prefix in pkg_prefixes\n+                ):\n                     continue\n \n-            parts_ = parts(direntry.path)\n-            if any(\n-                str(pkg_prefix) in parts_ and pkg_prefix.join(\"__init__.py\") != path\n-                for pkg_prefix in pkg_prefixes\n-            ):\n-                continue\n-\n-            if direntry.is_file():\n-                yield from self._collectfile(path)\n-            elif not direntry.is_dir():\n-                # Broken symlink or invalid/missing file.\n+                if direntry.is_file():\n+                    yield from self._collectfile(path)\n+                elif not direntry.is_dir():\n+                    # Broken symlink or invalid/missing file.\n+                    continue\n+                elif path.join(\"__init__.py\").check(file=1):\n+                    pkg_prefixes.add(path)\n+            except OSError:\n+                # Skip entries that can't be accessed (e.g., circular symlinks)\n                 continue\n-            elif path.join(\"__init__.py\").check(file=1):\n-                pkg_prefixes.add(path)\n \n \n def _call_with_optional_argument(func, arg) -> None:\n"}