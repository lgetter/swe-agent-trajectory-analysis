{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-13279", "model_patch": "diff --git a/django/contrib/sessions/backends/base.py b/django/contrib/sessions/backends/base.py\nindex b5453160a5..baaf77ccf5 100644\n--- a/django/contrib/sessions/backends/base.py\n+++ b/django/contrib/sessions/backends/base.py\n@@ -108,6 +108,13 @@ class SessionBase:\n \n     def encode(self, session_dict):\n         \"Return the given session dictionary serialized and encoded as a string.\"\n+        # RemovedInDjango40Warning: when the deprecation ends, remove the\n+        # legacy format.\n+        if settings.DEFAULT_HASHING_ALGORITHM == 'sha1':\n+            # Use legacy format when DEFAULT_HASHING_ALGORITHM is 'sha1' to\n+            # allow multiple instances with different DEFAULT_HASHING_ALGORITHM\n+            # values to share sessions during the Django 3.1 transition period.\n+            return self._legacy_encode(session_dict)\n         return signing.dumps(\n             session_dict, salt=self.key_salt, serializer=self.serializer,\n             compress=True,\n@@ -116,15 +123,45 @@ class SessionBase:\n     def decode(self, session_data):\n         try:\n             return signing.loads(session_data, salt=self.key_salt, serializer=self.serializer)\n-        # RemovedInDjango40Warning: when the deprecation ends, handle here\n-        # exceptions similar to what _legacy_decode() does now.\n         except Exception:\n+            # RemovedInDjango40Warning: when the deprecation ends, handle here\n+            # exceptions similar to what _legacy_decode() does now.\n+            \n+            # During the transition period, if DEFAULT_HASHING_ALGORITHM is 'sha1',\n+            # also try to decode with 'sha256' algorithm for compatibility with\n+            # sessions encoded by instances using sha256.\n+            if settings.DEFAULT_HASHING_ALGORITHM == 'sha1':\n+                try:\n+                    # Try to decode using sha256 algorithm\n+                    signer = signing.TimestampSigner(\n+                        key=settings.SECRET_KEY,\n+                        salt=self.key_salt,\n+                        algorithm='sha256'\n+                    )\n+                    base64d = signer.unsign(session_data).encode()\n+                    decompress = base64d[:1] == b'.'\n+                    if decompress:\n+                        base64d = base64d[1:]\n+                    data = signing.b64_decode(base64d)\n+                    if decompress:\n+                        import zlib\n+                        data = zlib.decompress(data)\n+                    return self.serializer().loads(data)\n+                except Exception:\n+                    pass\n+            \n             return self._legacy_decode(session_data)\n \n+    def _legacy_encode(self, session_dict):\n+        # RemovedInDjango40Warning: pre-Django 3.1 format will be invalid.\n+        serialized = self.serializer().dumps(session_dict)\n+        hash = self._hash(serialized)\n+        return base64.b64encode(hash.encode() + b\":\" + serialized).decode('ascii')\n+\n     def _legacy_decode(self, session_data):\n         # RemovedInDjango40Warning: pre-Django 3.1 format will be invalid.\n-        encoded_data = base64.b64decode(session_data.encode('ascii'))\n         try:\n+            encoded_data = base64.b64decode(session_data.encode('ascii'))\n             # could produce ValueError if there is no ':'\n             hash, serialized = encoded_data.split(b':', 1)\n             expected_hash = self._hash(serialized)\n"}