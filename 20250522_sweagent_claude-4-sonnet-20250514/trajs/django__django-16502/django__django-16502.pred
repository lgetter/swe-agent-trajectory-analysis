{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-16502", "model_patch": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e58..0b344cc995 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -143,6 +143,35 @@ class ServerHandler(simple_server.ServerHandler):\n         if self.headers.get(\"Connection\") == \"close\":\n             self.request_handler.close_connection = True\n \n+    def finish_response(self):\n+        \"\"\"\n+        Send any iterable data, then close self and the iterable.\n+        \n+        For HEAD requests, skip sending the response body to comply with RFC 2616.\n+        \"\"\"\n+        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n+            # For HEAD requests, don't send the response body\n+            try:\n+                # Still need to iterate through the result to ensure any cleanup\n+                # code in the response iterator is executed, but don't write the data\n+                for data in self.result:\n+                    pass  # Consume the iterator but don't send data\n+                self.finish_content()\n+            except:\n+                # Call close() on the iterable returned by the WSGI application\n+                # in case of an exception.\n+                if hasattr(self.result, 'close'):\n+                    self.result.close()\n+                raise\n+            else:\n+                # We only call close() when no exception is raised, because it\n+                # will set status, result, headers, and environ fields to None.\n+                # See bpo-29183 for more details.\n+                self.close()\n+        else:\n+            # For non-HEAD requests, use the default behavior\n+            super().finish_response()\n+\n     def close(self):\n         self.get_stdin().read()\n         super().close()\ndiff --git a/final_verification.py b/final_verification.py\nnew file mode 100644\nindex 0000000000..a2b23c2b2c\n--- /dev/null\n+++ b/final_verification.py\n@@ -0,0 +1,298 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Final verification that the HEAD request fix works correctly.\n+This test reproduces the exact scenario described in the PR.\n+\"\"\"\n+import os\n+import sys\n+import tempfile\n+import subprocess\n+import time\n+\n+# Add Django to the path\n+sys.path.insert(0, '/testbed')\n+\n+def create_django_project():\n+    \"\"\"Create a Django project exactly as described in the PR.\"\"\"\n+    project_dir = tempfile.mkdtemp()\n+    \n+    # Create manage.py\n+    manage_py = \"\"\"#!/usr/bin/env python\n+import os\n+import sys\n+\n+if __name__ == '__main__':\n+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_test.settings')\n+    try:\n+        from django.core.management import execute_from_command_line\n+    except ImportError as exc:\n+        raise ImportError(\n+            \"Couldn't import Django. Are you sure it's installed and \"\n+            \"available on your PYTHONPATH environment variable? Did you \"\n+            \"forget to activate a virtual environment?\"\n+        ) from exc\n+    execute_from_command_line(sys.argv)\n+\"\"\"\n+    \n+    # Create django_test directory\n+    django_test_dir = os.path.join(project_dir, 'django_test')\n+    os.makedirs(django_test_dir)\n+    \n+    # Create django_test/__init__.py\n+    init_py = \"\"\n+    \n+    # Create django_test/settings.py\n+    settings_py = \"\"\"\n+import os\n+from pathlib import Path\n+\n+BASE_DIR = Path(__file__).resolve().parent.parent\n+\n+SECRET_KEY = 'test-secret-key'\n+DEBUG = True\n+ALLOWED_HOSTS = ['*']\n+\n+INSTALLED_APPS = [\n+    'django.contrib.admin',\n+    'django.contrib.auth',\n+    'django.contrib.contenttypes',\n+    'django.contrib.sessions',\n+    'django.contrib.messages',\n+    'django.contrib.staticfiles',\n+]\n+\n+MIDDLEWARE = [\n+    'django.middleware.security.SecurityMiddleware',\n+    'django.contrib.sessions.middleware.SessionMiddleware',\n+    'django.middleware.common.CommonMiddleware',\n+    'django.middleware.csrf.CsrfViewMiddleware',\n+    'django.contrib.auth.middleware.AuthenticationMiddleware',\n+    'django.contrib.messages.middleware.MessageMiddleware',\n+    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n+]\n+\n+ROOT_URLCONF = 'django_test.urls'\n+\n+TEMPLATES = [\n+    {\n+        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        'DIRS': [],\n+        'APP_DIRS': True,\n+        'OPTIONS': {\n+            'context_processors': [\n+                'django.template.context_processors.debug',\n+                'django.template.context_processors.request',\n+                'django.contrib.auth.context_processors.auth',\n+                'django.contrib.messages.context_processors.messages',\n+            ],\n+        },\n+    },\n+]\n+\n+WSGI_APPLICATION = 'django_test.wsgi.application'\n+\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }\n+}\n+\n+LANGUAGE_CODE = 'en-us'\n+TIME_ZONE = 'UTC'\n+USE_I18N = True\n+USE_TZ = True\n+\n+STATIC_URL = '/static/'\n+DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'\n+\"\"\"\n+    \n+    # Create django_test/urls.py\n+    urls_py = \"\"\"\n+from django.contrib import admin\n+from django.urls import path\n+from django.http import HttpResponse\n+\n+def welcome_view(request):\n+    return HttpResponse('''<!DOCTYPE html>\n+<html lang=\"en\"><head>\n+ <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n+ <meta name=\"robots\" content=\"NONE,NOARCHIVE\"><title>Welcome to Django</title>\n+</head>\n+<body>\n+<h1>Welcome to Django</h1>\n+<p>Congratulations on your first Django-powered page.</p>\n+</body>\n+</html>''', content_type='text/html')\n+\n+urlpatterns = [\n+    path('admin/', admin.site.urls),\n+    path('', welcome_view, name='welcome'),\n+]\n+\"\"\"\n+    \n+    # Create django_test/wsgi.py\n+    wsgi_py = \"\"\"\n+import os\n+from django.core.wsgi import get_wsgi_application\n+\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_test.settings')\n+application = get_wsgi_application()\n+\"\"\"\n+    \n+    # Write all files\n+    with open(os.path.join(project_dir, 'manage.py'), 'w') as f:\n+        f.write(manage_py)\n+    os.chmod(os.path.join(project_dir, 'manage.py'), 0o755)\n+    \n+    with open(os.path.join(django_test_dir, '__init__.py'), 'w') as f:\n+        f.write(init_py)\n+    \n+    with open(os.path.join(django_test_dir, 'settings.py'), 'w') as f:\n+        f.write(settings_py)\n+    \n+    with open(os.path.join(django_test_dir, 'urls.py'), 'w') as f:\n+        f.write(urls_py)\n+    \n+    with open(os.path.join(django_test_dir, 'wsgi.py'), 'w') as f:\n+        f.write(wsgi_py)\n+    \n+    return project_dir\n+\n+def test_pr_scenario():\n+    \"\"\"Test the exact scenario described in the PR.\"\"\"\n+    print(\"=== Final Verification Test ===\")\n+    print(\"Reproducing the exact scenario from the PR description...\")\n+    \n+    project_dir = create_django_project()\n+    print(f\"Created Django project in: {project_dir}\")\n+    \n+    # Start the server in background\n+    env = os.environ.copy()\n+    env['PYTHONPATH'] = '/testbed'\n+    \n+    server_process = subprocess.Popen(\n+        [sys.executable, 'manage.py', 'runserver', '127.0.0.1:8000'],\n+        cwd=project_dir,\n+        env=env,\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE\n+    )\n+    \n+    try:\n+        # Wait for server to start\n+        print(\"Starting Django runserver...\")\n+        time.sleep(4)\n+        \n+        # Make HEAD request using curl exactly as in the PR\n+        print(\"Making HEAD request: curl -iX HEAD http://127.0.0.1:8000/\")\n+        result = subprocess.run(\n+            ['curl', '-iX', 'HEAD', 'http://127.0.0.1:8000/'],\n+            capture_output=True,\n+            text=True,\n+            timeout=15\n+        )\n+        \n+        print(\"\\n=== Response ===\")\n+        print(result.stdout)\n+        \n+        if result.stderr:\n+            print(\"=== Curl stderr ===\")\n+            print(result.stderr)\n+        \n+        # Parse the response\n+        lines = result.stdout.split('\\n')\n+        headers_ended = False\n+        body_lines = []\n+        status_line = \"\"\n+        headers = []\n+        \n+        for line in lines:\n+            if not status_line and line.startswith('HTTP/'):\n+                status_line = line\n+            elif not headers_ended:\n+                if line.strip() == '':  # Empty line marks end of headers\n+                    headers_ended = True\n+                else:\n+                    headers.append(line)\n+            else:\n+                if line.strip():  # Non-empty line in body\n+                    body_lines.append(line)\n+        \n+        print(\"\\n=== Analysis ===\")\n+        print(f\"Status line: {status_line}\")\n+        print(f\"Number of headers: {len(headers)}\")\n+        print(f\"Body lines found: {len(body_lines)}\")\n+        \n+        # Check expected headers\n+        expected_headers = ['Date:', 'Server:', 'Content-Type:', 'X-Frame-Options:']\n+        found_headers = []\n+        for header in headers:\n+            for expected in expected_headers:\n+                if header.startswith(expected):\n+                    found_headers.append(expected.rstrip(':'))\n+        \n+        print(f\"Expected headers found: {found_headers}\")\n+        \n+        # Verify the fix\n+        success = True\n+        \n+        if not status_line.startswith('HTTP/1.'):\n+            print(\"\u274c ERROR: Invalid HTTP status line\")\n+            success = False\n+        elif '200 OK' not in status_line:\n+            print(\"\u274c ERROR: Expected 200 OK status\")\n+            success = False\n+        \n+        if 'Server:' not in ' '.join(headers):\n+            print(\"\u274c ERROR: Missing Server header\")\n+            success = False\n+        elif 'WSGIServer' not in ' '.join(headers):\n+            print(\"\u274c ERROR: Expected WSGIServer in headers\")\n+            success = False\n+        \n+        if 'Content-Type:' not in ' '.join(headers):\n+            print(\"\u274c ERROR: Missing Content-Type header\")\n+            success = False\n+        \n+        if 'X-Frame-Options:' not in ' '.join(headers):\n+            print(\"\u274c ERROR: Missing X-Frame-Options header\")\n+            success = False\n+        \n+        if body_lines:\n+            print(\"\u274c ERROR: HEAD request returned response body!\")\n+            print(\"Body content found:\")\n+            for line in body_lines[:5]:\n+                print(f\"  {repr(line)}\")\n+            success = False\n+        else:\n+            print(\"\u2705 SUCCESS: HEAD request returned no body (RFC 2616 compliant)\")\n+        \n+        return success\n+        \n+    except subprocess.TimeoutExpired:\n+        print(\"\u274c ERROR: Request timed out\")\n+        return False\n+    except Exception as e:\n+        print(f\"\u274c ERROR: {e}\")\n+        return False\n+    finally:\n+        # Clean up server process\n+        print(\"\\nCleaning up server...\")\n+        server_process.terminate()\n+        try:\n+            server_process.wait(timeout=5)\n+        except subprocess.TimeoutExpired:\n+            server_process.kill()\n+\n+if __name__ == '__main__':\n+    success = test_pr_scenario()\n+    \n+    print(\"\\n\" + \"=\"*50)\n+    if success:\n+        print(\"\ud83c\udf89 SUCCESS: The issue has been fixed!\")\n+        print(\"HEAD requests from Django runserver are now RFC 2616 compliant.\")\n+        sys.exit(0)\n+    else:\n+        print(\"\u274c FAILURE: The issue is not fixed.\")\n+        sys.exit(1)\n\\ No newline at end of file\ndiff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 0000000000..d9a101041c\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,100 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Script to reproduce the HEAD request issue with Django runserver.\n+\"\"\"\n+import os\n+import sys\n+import subprocess\n+import time\n+import threading\n+import requests\n+\n+# Add Django to the path\n+sys.path.insert(0, '/testbed')\n+\n+# Set up Django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+\n+import django\n+from django.conf import settings\n+from django.core.management import execute_from_command_line\n+from django.http import HttpResponse\n+from django.urls import path\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        SECRET_KEY='test-secret-key',\n+        ROOT_URLCONF='reproduce_issue',\n+        ALLOWED_HOSTS=['*'],\n+        USE_TZ=True,\n+    )\n+\n+django.setup()\n+\n+def test_view(request):\n+    \"\"\"Simple test view that returns HTML content.\"\"\"\n+    return HttpResponse(\"\"\"<!DOCTYPE html>\n+<html lang=\"en\"><head>\n+ <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n+ <meta name=\"robots\" content=\"NONE,NOARCHIVE\"><title>Welcome to Django</title>\n+</head>\n+<body>\n+<h1>Welcome to Django</h1>\n+<p>This is a test page.</p>\n+</body>\n+</html>\"\"\", content_type='text/html')\n+\n+# URL patterns\n+urlpatterns = [\n+    path('', test_view, name='test'),\n+]\n+\n+def run_server():\n+    \"\"\"Run the Django development server.\"\"\"\n+    execute_from_command_line(['manage.py', 'runserver', '127.0.0.1:8000'])\n+\n+def test_head_request():\n+    \"\"\"Test HEAD request to the server.\"\"\"\n+    time.sleep(2)  # Give server time to start\n+    \n+    try:\n+        # Make a HEAD request\n+        response = requests.head('http://127.0.0.1:8000/', timeout=5)\n+        \n+        print(\"HEAD Request Response:\")\n+        print(f\"Status Code: {response.status_code}\")\n+        print(\"Headers:\")\n+        for header, value in response.headers.items():\n+            print(f\"  {header}: {value}\")\n+        \n+        print(f\"\\nResponse Content Length: {len(response.content)}\")\n+        print(f\"Response Text: {repr(response.text)}\")\n+        \n+        if response.content:\n+            print(\"\\n\u274c ERROR: HEAD request returned response body!\")\n+            print(f\"Body content: {response.content[:200]}...\")\n+            return False\n+        else:\n+            print(\"\\n\u2705 SUCCESS: HEAD request returned no body (as expected)\")\n+            return True\n+            \n+    except Exception as e:\n+        print(f\"Error making request: {e}\")\n+        return False\n+\n+if __name__ == '__main__':\n+    # Start server in a separate thread\n+    server_thread = threading.Thread(target=run_server, daemon=True)\n+    server_thread.start()\n+    \n+    # Test HEAD request\n+    success = test_head_request()\n+    \n+    if not success:\n+        print(\"\\nThe issue is reproduced: HEAD requests return response bodies.\")\n+        sys.exit(1)\n+    else:\n+        print(\"\\nNo issue found: HEAD requests work correctly.\")\n+        sys.exit(0)\n\\ No newline at end of file\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..7cc6297465\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,211 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test edge cases for the HEAD request fix.\n+\"\"\"\n+import os\n+import sys\n+import tempfile\n+import subprocess\n+import time\n+\n+# Add Django to the path\n+sys.path.insert(0, '/testbed')\n+\n+def create_test_project():\n+    \"\"\"Create a minimal Django project.\"\"\"\n+    project_dir = tempfile.mkdtemp()\n+    \n+    # Create manage.py\n+    manage_py = f\"\"\"#!/usr/bin/env python\n+import os\n+import sys\n+\n+if __name__ == '__main__':\n+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')\n+    try:\n+        from django.core.management import execute_from_command_line\n+    except ImportError as exc:\n+        raise ImportError(\n+            \"Couldn't import Django. Are you sure it's installed and \"\n+            \"available on your PYTHONPATH environment variable? Did you \"\n+            \"forget to activate a virtual environment?\"\n+        ) from exc\n+    execute_from_command_line(sys.argv)\n+\"\"\"\n+    \n+    # Create settings.py\n+    settings_py = f\"\"\"\n+import os\n+from pathlib import Path\n+\n+BASE_DIR = Path(__file__).resolve().parent\n+\n+SECRET_KEY = 'test-secret-key'\n+DEBUG = True\n+ALLOWED_HOSTS = ['*']\n+\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'django.contrib.auth',\n+]\n+\n+MIDDLEWARE = [\n+    'django.middleware.security.SecurityMiddleware',\n+    'django.middleware.common.CommonMiddleware',\n+]\n+\n+ROOT_URLCONF = 'urls'\n+\n+DATABASES = {{\n+    'default': {{\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }}\n+}}\n+\n+USE_TZ = True\n+\"\"\"\n+    \n+    # Create urls.py with different response types\n+    urls_py = \"\"\"\n+from django.http import HttpResponse, StreamingHttpResponse, JsonResponse\n+from django.urls import path\n+\n+def test_view(request):\n+    return HttpResponse('''<!DOCTYPE html>\n+<html lang=\"en\"><head>\n+ <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n+ <meta name=\"robots\" content=\"NONE,NOARCHIVE\"><title>Welcome to Django</title>\n+</head>\n+<body>\n+<h1>Welcome to Django</h1>\n+<p>This is a test page with some content.</p>\n+</body>\n+</html>''', content_type='text/html')\n+\n+def streaming_view(request):\n+    def generate():\n+        yield \"First chunk\\\\n\"\n+        yield \"Second chunk\\\\n\"\n+        yield \"Third chunk\\\\n\"\n+    return StreamingHttpResponse(generate(), content_type='text/plain')\n+\n+def json_view(request):\n+    return JsonResponse({'message': 'Hello, world!', 'data': [1, 2, 3, 4, 5]})\n+\n+def empty_view(request):\n+    return HttpResponse('', content_type='text/plain')\n+\n+urlpatterns = [\n+    path('', test_view, name='test'),\n+    path('streaming/', streaming_view, name='streaming'),\n+    path('json/', json_view, name='json'),\n+    path('empty/', empty_view, name='empty'),\n+]\n+\"\"\"\n+    \n+    # Write files\n+    with open(os.path.join(project_dir, 'manage.py'), 'w') as f:\n+        f.write(manage_py)\n+    os.chmod(os.path.join(project_dir, 'manage.py'), 0o755)\n+    \n+    with open(os.path.join(project_dir, 'settings.py'), 'w') as f:\n+        f.write(settings_py)\n+    \n+    with open(os.path.join(project_dir, 'urls.py'), 'w') as f:\n+        f.write(urls_py)\n+    \n+    return project_dir\n+\n+def test_head_requests():\n+    \"\"\"Test HEAD requests for different response types.\"\"\"\n+    project_dir = create_test_project()\n+    \n+    print(f\"Created test project in: {project_dir}\")\n+    \n+    # Start the server in background\n+    env = os.environ.copy()\n+    env['PYTHONPATH'] = '/testbed'\n+    \n+    server_process = subprocess.Popen(\n+        [sys.executable, 'manage.py', 'runserver', '127.0.0.1:8003', '--noreload'],\n+        cwd=project_dir,\n+        env=env,\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE\n+    )\n+    \n+    try:\n+        # Wait for server to start\n+        print(\"Waiting for server to start...\")\n+        time.sleep(3)\n+        \n+        # Test different endpoints\n+        endpoints = [\n+            ('/', 'HTML response'),\n+            ('/streaming/', 'Streaming response'),\n+            ('/json/', 'JSON response'),\n+            ('/empty/', 'Empty response'),\n+        ]\n+        \n+        all_passed = True\n+        \n+        for endpoint, description in endpoints:\n+            print(f\"\\nTesting {description} at {endpoint}\")\n+            \n+            # Make HEAD request using curl\n+            result = subprocess.run(\n+                ['curl', '-i', '-X', 'HEAD', f'http://127.0.0.1:8003{endpoint}', '--max-time', '10'],\n+                capture_output=True,\n+                text=True,\n+                timeout=15\n+            )\n+            \n+            print(f\"Response for {description}:\")\n+            print(result.stdout[:200] + \"...\" if len(result.stdout) > 200 else result.stdout)\n+            \n+            # Check if there's a body in the response\n+            lines = result.stdout.split('\\n')\n+            headers_ended = False\n+            body_lines = []\n+            \n+            for line in lines:\n+                if headers_ended:\n+                    if line.strip():  # Non-empty line in body\n+                        body_lines.append(line)\n+                elif line.strip() == '':  # Empty line marks end of headers\n+                    headers_ended = True\n+            \n+            if body_lines:\n+                print(f\"\u274c ERROR: HEAD request for {description} returned response body!\")\n+                print(f\"Body lines: {len(body_lines)}\")\n+                all_passed = False\n+            else:\n+                print(f\"\u2705 SUCCESS: HEAD request for {description} returned no body\")\n+        \n+        return all_passed\n+            \n+    except subprocess.TimeoutExpired:\n+        print(\"Request timed out\")\n+        return False\n+    except Exception as e:\n+        print(f\"Error: {e}\")\n+        return False\n+    finally:\n+        # Clean up server process\n+        print(\"Cleaning up server...\")\n+        server_process.terminate()\n+        try:\n+            server_process.wait(timeout=5)\n+        except subprocess.TimeoutExpired:\n+            server_process.kill()\n+\n+if __name__ == '__main__':\n+    success = test_head_requests()\n+    \n+    if not success:\n+        print(\"\\nSome edge case tests failed.\")\n+        sys.exit(1)\n+    else:\n+        print(\"\\nAll edge case tests passed!\")\n+        sys.exit(0)\n\\ No newline at end of file\ndiff --git a/test_get_still_works.py b/test_get_still_works.py\nnew file mode 100644\nindex 0000000000..13e50a6f7d\n--- /dev/null\n+++ b/test_get_still_works.py\n@@ -0,0 +1,189 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test script to verify GET requests still work after the HEAD fix.\n+\"\"\"\n+import os\n+import sys\n+import tempfile\n+import subprocess\n+import time\n+\n+# Add Django to the path\n+sys.path.insert(0, '/testbed')\n+\n+def create_test_project():\n+    \"\"\"Create a minimal Django project.\"\"\"\n+    project_dir = tempfile.mkdtemp()\n+    \n+    # Create manage.py\n+    manage_py = f\"\"\"#!/usr/bin/env python\n+import os\n+import sys\n+\n+if __name__ == '__main__':\n+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')\n+    try:\n+        from django.core.management import execute_from_command_line\n+    except ImportError as exc:\n+        raise ImportError(\n+            \"Couldn't import Django. Are you sure it's installed and \"\n+            \"available on your PYTHONPATH environment variable? Did you \"\n+            \"forget to activate a virtual environment?\"\n+        ) from exc\n+    execute_from_command_line(sys.argv)\n+\"\"\"\n+    \n+    # Create settings.py\n+    settings_py = f\"\"\"\n+import os\n+from pathlib import Path\n+\n+BASE_DIR = Path(__file__).resolve().parent\n+\n+SECRET_KEY = 'test-secret-key'\n+DEBUG = True\n+ALLOWED_HOSTS = ['*']\n+\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'django.contrib.auth',\n+]\n+\n+MIDDLEWARE = [\n+    'django.middleware.security.SecurityMiddleware',\n+    'django.middleware.common.CommonMiddleware',\n+]\n+\n+ROOT_URLCONF = 'urls'\n+\n+DATABASES = {{\n+    'default': {{\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }}\n+}}\n+\n+USE_TZ = True\n+\"\"\"\n+    \n+    # Create urls.py\n+    urls_py = \"\"\"\n+from django.http import HttpResponse\n+from django.urls import path\n+\n+def test_view(request):\n+    return HttpResponse('''<!DOCTYPE html>\n+<html lang=\"en\"><head>\n+ <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n+ <meta name=\"robots\" content=\"NONE,NOARCHIVE\"><title>Welcome to Django</title>\n+</head>\n+<body>\n+<h1>Welcome to Django</h1>\n+<p>This is a test page with some content.</p>\n+</body>\n+</html>''', content_type='text/html')\n+\n+urlpatterns = [\n+    path('', test_view, name='test'),\n+]\n+\"\"\"\n+    \n+    # Write files\n+    with open(os.path.join(project_dir, 'manage.py'), 'w') as f:\n+        f.write(manage_py)\n+    os.chmod(os.path.join(project_dir, 'manage.py'), 0o755)\n+    \n+    with open(os.path.join(project_dir, 'settings.py'), 'w') as f:\n+        f.write(settings_py)\n+    \n+    with open(os.path.join(project_dir, 'urls.py'), 'w') as f:\n+        f.write(urls_py)\n+    \n+    return project_dir\n+\n+def test_get_request():\n+    \"\"\"Test GET request using curl.\"\"\"\n+    project_dir = create_test_project()\n+    \n+    print(f\"Created test project in: {project_dir}\")\n+    \n+    # Start the server in background\n+    env = os.environ.copy()\n+    env['PYTHONPATH'] = '/testbed'\n+    \n+    server_process = subprocess.Popen(\n+        [sys.executable, 'manage.py', 'runserver', '127.0.0.1:8002', '--noreload'],\n+        cwd=project_dir,\n+        env=env,\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE\n+    )\n+    \n+    try:\n+        # Wait for server to start\n+        print(\"Waiting for server to start...\")\n+        time.sleep(3)\n+        \n+        # Make GET request using curl\n+        print(\"Making GET request...\")\n+        result = subprocess.run(\n+            ['curl', '-i', 'http://127.0.0.1:8002/', '--max-time', '10'],\n+            capture_output=True,\n+            text=True,\n+            timeout=15\n+        )\n+        \n+        print(\"GET Request Response:\")\n+        print(result.stdout)\n+        \n+        if result.stderr:\n+            print(\"Curl stderr:\")\n+            print(result.stderr)\n+        \n+        # Check if there's a body in the response\n+        lines = result.stdout.split('\\n')\n+        headers_ended = False\n+        body_lines = []\n+        \n+        for line in lines:\n+            if headers_ended:\n+                if line.strip():  # Non-empty line in body\n+                    body_lines.append(line)\n+            elif line.strip() == '':  # Empty line marks end of headers\n+                headers_ended = True\n+        \n+        if body_lines:\n+            print(f\"\\n\u2705 SUCCESS: GET request returned response body as expected!\")\n+            print(f\"Body lines: {len(body_lines)}\")\n+            print(\"First few body lines:\")\n+            for line in body_lines[:3]:\n+                print(f\"  {repr(line)}\")\n+            return True\n+        else:\n+            print(\"\\n\u274c ERROR: GET request returned no body!\")\n+            return False\n+            \n+    except subprocess.TimeoutExpired:\n+        print(\"Request timed out\")\n+        return False\n+    except Exception as e:\n+        print(f\"Error: {e}\")\n+        return False\n+    finally:\n+        # Clean up server process\n+        print(\"Cleaning up server...\")\n+        server_process.terminate()\n+        try:\n+            server_process.wait(timeout=5)\n+        except subprocess.TimeoutExpired:\n+            server_process.kill()\n+\n+if __name__ == '__main__':\n+    success = test_get_request()\n+    \n+    if not success:\n+        print(\"\\nERROR: GET requests are broken!\")\n+        sys.exit(1)\n+    else:\n+        print(\"\\nSUCCESS: GET requests work correctly!\")\n+        sys.exit(0)\n\\ No newline at end of file\ndiff --git a/test_head_fix.py b/test_head_fix.py\nnew file mode 100644\nindex 0000000000..14b18a1bcc\n--- /dev/null\n+++ b/test_head_fix.py\n@@ -0,0 +1,189 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test script to verify the HEAD request fix.\n+\"\"\"\n+import os\n+import sys\n+import tempfile\n+import subprocess\n+import time\n+\n+# Add Django to the path\n+sys.path.insert(0, '/testbed')\n+\n+def create_test_project():\n+    \"\"\"Create a minimal Django project.\"\"\"\n+    project_dir = tempfile.mkdtemp()\n+    \n+    # Create manage.py\n+    manage_py = f\"\"\"#!/usr/bin/env python\n+import os\n+import sys\n+\n+if __name__ == '__main__':\n+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')\n+    try:\n+        from django.core.management import execute_from_command_line\n+    except ImportError as exc:\n+        raise ImportError(\n+            \"Couldn't import Django. Are you sure it's installed and \"\n+            \"available on your PYTHONPATH environment variable? Did you \"\n+            \"forget to activate a virtual environment?\"\n+        ) from exc\n+    execute_from_command_line(sys.argv)\n+\"\"\"\n+    \n+    # Create settings.py\n+    settings_py = f\"\"\"\n+import os\n+from pathlib import Path\n+\n+BASE_DIR = Path(__file__).resolve().parent\n+\n+SECRET_KEY = 'test-secret-key'\n+DEBUG = True\n+ALLOWED_HOSTS = ['*']\n+\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'django.contrib.auth',\n+]\n+\n+MIDDLEWARE = [\n+    'django.middleware.security.SecurityMiddleware',\n+    'django.middleware.common.CommonMiddleware',\n+]\n+\n+ROOT_URLCONF = 'urls'\n+\n+DATABASES = {{\n+    'default': {{\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }}\n+}}\n+\n+USE_TZ = True\n+\"\"\"\n+    \n+    # Create urls.py\n+    urls_py = \"\"\"\n+from django.http import HttpResponse\n+from django.urls import path\n+\n+def test_view(request):\n+    return HttpResponse('''<!DOCTYPE html>\n+<html lang=\"en\"><head>\n+ <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n+ <meta name=\"robots\" content=\"NONE,NOARCHIVE\"><title>Welcome to Django</title>\n+</head>\n+<body>\n+<h1>Welcome to Django</h1>\n+<p>This is a test page with some content that should not appear in HEAD responses.</p>\n+</body>\n+</html>''', content_type='text/html')\n+\n+urlpatterns = [\n+    path('', test_view, name='test'),\n+]\n+\"\"\"\n+    \n+    # Write files\n+    with open(os.path.join(project_dir, 'manage.py'), 'w') as f:\n+        f.write(manage_py)\n+    os.chmod(os.path.join(project_dir, 'manage.py'), 0o755)\n+    \n+    with open(os.path.join(project_dir, 'settings.py'), 'w') as f:\n+        f.write(settings_py)\n+    \n+    with open(os.path.join(project_dir, 'urls.py'), 'w') as f:\n+        f.write(urls_py)\n+    \n+    return project_dir\n+\n+def test_head_request():\n+    \"\"\"Test HEAD request using curl.\"\"\"\n+    project_dir = create_test_project()\n+    \n+    print(f\"Created test project in: {project_dir}\")\n+    \n+    # Start the server in background\n+    env = os.environ.copy()\n+    env['PYTHONPATH'] = '/testbed'\n+    \n+    server_process = subprocess.Popen(\n+        [sys.executable, 'manage.py', 'runserver', '127.0.0.1:8001', '--noreload'],\n+        cwd=project_dir,\n+        env=env,\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE\n+    )\n+    \n+    try:\n+        # Wait for server to start\n+        print(\"Waiting for server to start...\")\n+        time.sleep(3)\n+        \n+        # Make HEAD request using curl\n+        print(\"Making HEAD request...\")\n+        result = subprocess.run(\n+            ['curl', '-i', '-X', 'HEAD', 'http://127.0.0.1:8001/', '--max-time', '10'],\n+            capture_output=True,\n+            text=True,\n+            timeout=15\n+        )\n+        \n+        print(\"HEAD Request Response:\")\n+        print(result.stdout)\n+        \n+        if result.stderr:\n+            print(\"Curl stderr:\")\n+            print(result.stderr)\n+        \n+        # Check if there's a body in the response\n+        lines = result.stdout.split('\\n')\n+        headers_ended = False\n+        body_lines = []\n+        \n+        for line in lines:\n+            if headers_ended:\n+                if line.strip():  # Non-empty line in body\n+                    body_lines.append(line)\n+            elif line.strip() == '':  # Empty line marks end of headers\n+                headers_ended = True\n+        \n+        if body_lines:\n+            print(f\"\\n\u274c ERROR: HEAD request returned response body!\")\n+            print(f\"Body lines: {len(body_lines)}\")\n+            print(\"First few body lines:\")\n+            for line in body_lines[:5]:\n+                print(f\"  {repr(line)}\")\n+            return False\n+        else:\n+            print(\"\\n\u2705 SUCCESS: HEAD request returned no body (as expected)\")\n+            return True\n+            \n+    except subprocess.TimeoutExpired:\n+        print(\"Request timed out\")\n+        return False\n+    except Exception as e:\n+        print(f\"Error: {e}\")\n+        return False\n+    finally:\n+        # Clean up server process\n+        print(\"Cleaning up server...\")\n+        server_process.terminate()\n+        try:\n+            server_process.wait(timeout=5)\n+        except subprocess.TimeoutExpired:\n+            server_process.kill()\n+\n+if __name__ == '__main__':\n+    success = test_head_request()\n+    \n+    if not success:\n+        print(\"\\nThe issue is still present: HEAD requests return response bodies.\")\n+        sys.exit(1)\n+    else:\n+        print(\"\\nSUCCESS: HEAD requests work correctly now!\")\n+        sys.exit(0)\n\\ No newline at end of file\ndiff --git a/test_head_simple.py b/test_head_simple.py\nnew file mode 100644\nindex 0000000000..bc32f73d3a\n--- /dev/null\n+++ b/test_head_simple.py\n@@ -0,0 +1,183 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Simple script to test HEAD request behavior using curl.\n+\"\"\"\n+import os\n+import sys\n+import subprocess\n+import tempfile\n+import time\n+\n+# Add Django to the path\n+sys.path.insert(0, '/testbed')\n+\n+# Create a minimal Django project for testing\n+def create_test_project():\n+    \"\"\"Create a minimal Django project.\"\"\"\n+    project_dir = tempfile.mkdtemp()\n+    \n+    # Create manage.py\n+    manage_py = f\"\"\"#!/usr/bin/env python\n+import os\n+import sys\n+\n+if __name__ == '__main__':\n+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')\n+    try:\n+        from django.core.management import execute_from_command_line\n+    except ImportError as exc:\n+        raise ImportError(\n+            \"Couldn't import Django. Are you sure it's installed and \"\n+            \"available on your PYTHONPATH environment variable? Did you \"\n+            \"forget to activate a virtual environment?\"\n+        ) from exc\n+    execute_from_command_line(sys.argv)\n+\"\"\"\n+    \n+    # Create settings.py\n+    settings_py = f\"\"\"\n+import os\n+from pathlib import Path\n+\n+BASE_DIR = Path(__file__).resolve().parent\n+\n+SECRET_KEY = 'test-secret-key'\n+DEBUG = True\n+ALLOWED_HOSTS = ['*']\n+\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'django.contrib.auth',\n+]\n+\n+MIDDLEWARE = [\n+    'django.middleware.security.SecurityMiddleware',\n+    'django.middleware.common.CommonMiddleware',\n+]\n+\n+ROOT_URLCONF = 'urls'\n+\n+DATABASES = {{\n+    'default': {{\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }}\n+}}\n+\n+USE_TZ = True\n+\"\"\"\n+    \n+    # Create urls.py\n+    urls_py = \"\"\"\n+from django.http import HttpResponse\n+from django.urls import path\n+\n+def test_view(request):\n+    return HttpResponse('''<!DOCTYPE html>\n+<html lang=\"en\"><head>\n+ <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n+ <meta name=\"robots\" content=\"NONE,NOARCHIVE\"><title>Welcome to Django</title>\n+</head>\n+<body>\n+<h1>Welcome to Django</h1>\n+<p>This is a test page.</p>\n+</body>\n+</html>''', content_type='text/html')\n+\n+urlpatterns = [\n+    path('', test_view, name='test'),\n+]\n+\"\"\"\n+    \n+    # Write files\n+    with open(os.path.join(project_dir, 'manage.py'), 'w') as f:\n+        f.write(manage_py)\n+    os.chmod(os.path.join(project_dir, 'manage.py'), 0o755)\n+    \n+    with open(os.path.join(project_dir, 'settings.py'), 'w') as f:\n+        f.write(settings_py)\n+    \n+    with open(os.path.join(project_dir, 'urls.py'), 'w') as f:\n+        f.write(urls_py)\n+    \n+    return project_dir\n+\n+def test_head_request():\n+    \"\"\"Test HEAD request using curl.\"\"\"\n+    project_dir = create_test_project()\n+    \n+    print(f\"Created test project in: {project_dir}\")\n+    \n+    # Start the server in background\n+    env = os.environ.copy()\n+    env['PYTHONPATH'] = '/testbed'\n+    \n+    server_process = subprocess.Popen(\n+        [sys.executable, 'manage.py', 'runserver', '127.0.0.1:8000', '--noreload'],\n+        cwd=project_dir,\n+        env=env,\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE\n+    )\n+    \n+    try:\n+        # Wait for server to start\n+        time.sleep(3)\n+        \n+        # Make HEAD request using curl\n+        result = subprocess.run(\n+            ['curl', '-i', '-X', 'HEAD', 'http://127.0.0.1:8000/'],\n+            capture_output=True,\n+            text=True,\n+            timeout=10\n+        )\n+        \n+        print(\"HEAD Request Response:\")\n+        print(result.stdout)\n+        \n+        # Check if there's a body in the response\n+        lines = result.stdout.split('\\n')\n+        headers_ended = False\n+        body_lines = []\n+        \n+        for line in lines:\n+            if headers_ended:\n+                if line.strip():  # Non-empty line in body\n+                    body_lines.append(line)\n+            elif line.strip() == '':  # Empty line marks end of headers\n+                headers_ended = True\n+        \n+        if body_lines:\n+            print(f\"\\n\u274c ERROR: HEAD request returned response body!\")\n+            print(f\"Body lines: {len(body_lines)}\")\n+            print(\"First few body lines:\")\n+            for line in body_lines[:5]:\n+                print(f\"  {repr(line)}\")\n+            return False\n+        else:\n+            print(\"\\n\u2705 SUCCESS: HEAD request returned no body (as expected)\")\n+            return True\n+            \n+    except subprocess.TimeoutExpired:\n+        print(\"Request timed out\")\n+        return False\n+    except Exception as e:\n+        print(f\"Error: {e}\")\n+        return False\n+    finally:\n+        # Clean up server process\n+        server_process.terminate()\n+        try:\n+            server_process.wait(timeout=5)\n+        except subprocess.TimeoutExpired:\n+            server_process.kill()\n+\n+if __name__ == '__main__':\n+    success = test_head_request()\n+    \n+    if not success:\n+        print(\"\\nThe issue is reproduced: HEAD requests return response bodies.\")\n+        sys.exit(1)\n+    else:\n+        print(\"\\nNo issue found: HEAD requests work correctly.\")\n+        sys.exit(0)\n\\ No newline at end of file\ndiff --git a/test_other_methods.py b/test_other_methods.py\nnew file mode 100644\nindex 0000000000..aa0edb89e0\n--- /dev/null\n+++ b/test_other_methods.py\n@@ -0,0 +1,227 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test that other HTTP methods still work correctly after the HEAD fix.\n+\"\"\"\n+import os\n+import sys\n+import tempfile\n+import subprocess\n+import time\n+\n+# Add Django to the path\n+sys.path.insert(0, '/testbed')\n+\n+def create_test_project():\n+    \"\"\"Create a minimal Django project.\"\"\"\n+    project_dir = tempfile.mkdtemp()\n+    \n+    # Create manage.py\n+    manage_py = f\"\"\"#!/usr/bin/env python\n+import os\n+import sys\n+\n+if __name__ == '__main__':\n+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')\n+    try:\n+        from django.core.management import execute_from_command_line\n+    except ImportError as exc:\n+        raise ImportError(\n+            \"Couldn't import Django. Are you sure it's installed and \"\n+            \"available on your PYTHONPATH environment variable? Did you \"\n+            \"forget to activate a virtual environment?\"\n+        ) from exc\n+    execute_from_command_line(sys.argv)\n+\"\"\"\n+    \n+    # Create settings.py\n+    settings_py = f\"\"\"\n+import os\n+from pathlib import Path\n+\n+BASE_DIR = Path(__file__).resolve().parent\n+\n+SECRET_KEY = 'test-secret-key'\n+DEBUG = True\n+ALLOWED_HOSTS = ['*']\n+\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'django.contrib.auth',\n+]\n+\n+MIDDLEWARE = [\n+    'django.middleware.security.SecurityMiddleware',\n+    'django.middleware.common.CommonMiddleware',\n+]\n+\n+ROOT_URLCONF = 'urls'\n+\n+DATABASES = {{\n+    'default': {{\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }}\n+}}\n+\n+USE_TZ = True\n+\"\"\"\n+    \n+    # Create urls.py\n+    urls_py = \"\"\"\n+from django.http import HttpResponse, JsonResponse\n+from django.urls import path\n+from django.views.decorators.csrf import csrf_exempt\n+import json\n+\n+def test_view(request):\n+    return HttpResponse('''<!DOCTYPE html>\n+<html lang=\"en\"><head>\n+ <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n+ <meta name=\"robots\" content=\"NONE,NOARCHIVE\"><title>Welcome to Django</title>\n+</head>\n+<body>\n+<h1>Welcome to Django</h1>\n+<p>This is a test page.</p>\n+</body>\n+</html>''', content_type='text/html')\n+\n+@csrf_exempt\n+def post_view(request):\n+    if request.method == 'POST':\n+        return JsonResponse({'method': 'POST', 'received': 'data'})\n+    return JsonResponse({'error': 'Only POST allowed'}, status=405)\n+\n+@csrf_exempt\n+def put_view(request):\n+    if request.method == 'PUT':\n+        return JsonResponse({'method': 'PUT', 'received': 'data'})\n+    return JsonResponse({'error': 'Only PUT allowed'}, status=405)\n+\n+def options_view(request):\n+    response = HttpResponse('')\n+    response['Allow'] = 'GET, HEAD, POST, PUT, OPTIONS'\n+    return response\n+\n+urlpatterns = [\n+    path('', test_view, name='test'),\n+    path('post/', post_view, name='post'),\n+    path('put/', put_view, name='put'),\n+    path('options/', options_view, name='options'),\n+]\n+\"\"\"\n+    \n+    # Write files\n+    with open(os.path.join(project_dir, 'manage.py'), 'w') as f:\n+        f.write(manage_py)\n+    os.chmod(os.path.join(project_dir, 'manage.py'), 0o755)\n+    \n+    with open(os.path.join(project_dir, 'settings.py'), 'w') as f:\n+        f.write(settings_py)\n+    \n+    with open(os.path.join(project_dir, 'urls.py'), 'w') as f:\n+        f.write(urls_py)\n+    \n+    return project_dir\n+\n+def test_http_methods():\n+    \"\"\"Test different HTTP methods.\"\"\"\n+    project_dir = create_test_project()\n+    \n+    print(f\"Created test project in: {project_dir}\")\n+    \n+    # Start the server in background\n+    env = os.environ.copy()\n+    env['PYTHONPATH'] = '/testbed'\n+    \n+    server_process = subprocess.Popen(\n+        [sys.executable, 'manage.py', 'runserver', '127.0.0.1:8004', '--noreload'],\n+        cwd=project_dir,\n+        env=env,\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE\n+    )\n+    \n+    try:\n+        # Wait for server to start\n+        print(\"Waiting for server to start...\")\n+        time.sleep(3)\n+        \n+        # Test different HTTP methods\n+        tests = [\n+            ('GET', '/', 'GET request should have body', True),\n+            ('POST', '/post/', 'POST request should have body', True),\n+            ('PUT', '/put/', 'PUT request should have body', True),\n+            ('OPTIONS', '/options/', 'OPTIONS request may have empty body', False),\n+        ]\n+        \n+        all_passed = True\n+        \n+        for method, endpoint, description, should_have_body in tests:\n+            print(f\"\\nTesting {method} request to {endpoint}\")\n+            \n+            # Make request using curl\n+            if method == 'POST':\n+                curl_cmd = ['curl', '-i', '-X', 'POST', '-d', 'test=data', f'http://127.0.0.1:8004{endpoint}', '--max-time', '10']\n+            elif method == 'PUT':\n+                curl_cmd = ['curl', '-i', '-X', 'PUT', '-d', 'test=data', f'http://127.0.0.1:8004{endpoint}', '--max-time', '10']\n+            else:\n+                curl_cmd = ['curl', '-i', '-X', method, f'http://127.0.0.1:8004{endpoint}', '--max-time', '10']\n+            \n+            result = subprocess.run(\n+                curl_cmd,\n+                capture_output=True,\n+                text=True,\n+                timeout=15\n+            )\n+            \n+            print(f\"Response for {method} request:\")\n+            print(result.stdout[:300] + \"...\" if len(result.stdout) > 300 else result.stdout)\n+            \n+            # Check if there's a body in the response\n+            lines = result.stdout.split('\\n')\n+            headers_ended = False\n+            body_lines = []\n+            \n+            for line in lines:\n+                if headers_ended:\n+                    if line.strip():  # Non-empty line in body\n+                        body_lines.append(line)\n+                elif line.strip() == '':  # Empty line marks end of headers\n+                    headers_ended = True\n+            \n+            if should_have_body:\n+                if not body_lines:\n+                    print(f\"\u274c ERROR: {method} request returned no body!\")\n+                    all_passed = False\n+                else:\n+                    print(f\"\u2705 SUCCESS: {method} request returned body as expected\")\n+            else:\n+                # For OPTIONS and other methods that may have empty bodies\n+                print(f\"\u2705 SUCCESS: {method} request completed (body optional)\")\n+        \n+        return all_passed\n+            \n+    except subprocess.TimeoutExpired:\n+        print(\"Request timed out\")\n+        return False\n+    except Exception as e:\n+        print(f\"Error: {e}\")\n+        return False\n+    finally:\n+        # Clean up server process\n+        print(\"Cleaning up server...\")\n+        server_process.terminate()\n+        try:\n+            server_process.wait(timeout=5)\n+        except subprocess.TimeoutExpired:\n+            server_process.kill()\n+\n+if __name__ == '__main__':\n+    success = test_http_methods()\n+    \n+    if not success:\n+        print(\"\\nSome HTTP method tests failed.\")\n+        sys.exit(1)\n+    else:\n+        print(\"\\nAll HTTP method tests passed!\")\n+        sys.exit(0)\n\\ No newline at end of file\ndiff --git a/tests/servers/test_basehttp.py b/tests/servers/test_basehttp.py\nindex a837505feb..ea77e36c54 100644\n--- a/tests/servers/test_basehttp.py\n+++ b/tests/servers/test_basehttp.py\n@@ -106,6 +106,115 @@ class WSGIRequestHandlerTestCase(SimpleTestCase):\n \n         self.assertEqual(body, b\"HTTP_SOME_HEADER:good\")\n \n+    def test_head_request_no_body(self):\n+        \"\"\"HEAD requests should not return response body.\"\"\"\n+        \n+        def test_app(environ, start_response):\n+            \"\"\"A WSGI app that returns a response with body content.\"\"\"\n+            start_response(\"200 OK\", [(\"Content-Type\", \"text/html\")])\n+            yield b\"<!DOCTYPE html><html><head><title>Test</title></head>\"\n+            yield b\"<body><h1>Test Page</h1><p>This is test content.</p></body></html>\"\n+\n+        # Test HEAD request\n+        rfile = BytesIO()\n+        rfile.write(b\"HEAD / HTTP/1.0\\r\\n\")\n+        rfile.write(b\"Host: testserver\\r\\n\")\n+        rfile.write(b\"\\r\\n\")\n+        rfile.seek(0)\n+\n+        # WSGIRequestHandler closes the output file; we need to make this a\n+        # no-op so we can still read its contents.\n+        class UnclosableBytesIO(BytesIO):\n+            def close(self):\n+                pass\n+\n+        wfile = UnclosableBytesIO()\n+\n+        def makefile(mode, *a, **kw):\n+            if mode == \"rb\":\n+                return rfile\n+            elif mode == \"wb\":\n+                return wfile\n+\n+        request = Stub(makefile=makefile)\n+        server = Stub(base_environ={}, get_app=lambda: test_app)\n+\n+        # Prevent logging from appearing in test output.\n+        with self.assertLogs(\"django.server\", \"INFO\"):\n+            # instantiating a handler runs the request as side effect\n+            WSGIRequestHandler(request, \"192.168.0.2\", server)\n+\n+        wfile.seek(0)\n+        response_data = wfile.read()\n+        \n+        # Split headers and body\n+        response_str = response_data.decode('utf-8', errors='ignore')\n+        parts = response_str.split('\\r\\n\\r\\n', 1)\n+        headers = parts[0]\n+        body = parts[1] if len(parts) > 1 else \"\"\n+        \n+        # Verify we have headers\n+        self.assertIn(\"HTTP/1.1 200 OK\", headers)\n+        self.assertIn(\"Content-Type: text/html\", headers)\n+        \n+        # Verify no body content for HEAD request\n+        self.assertEqual(body.strip(), \"\", \"HEAD request should not return response body\")\n+\n+    def test_get_request_has_body(self):\n+        \"\"\"GET requests should return response body (control test).\"\"\"\n+        \n+        def test_app(environ, start_response):\n+            \"\"\"A WSGI app that returns a response with body content.\"\"\"\n+            start_response(\"200 OK\", [(\"Content-Type\", \"text/html\")])\n+            yield b\"<!DOCTYPE html><html><head><title>Test</title></head>\"\n+            yield b\"<body><h1>Test Page</h1><p>This is test content.</p></body></html>\"\n+\n+        # Test GET request\n+        rfile = BytesIO()\n+        rfile.write(b\"GET / HTTP/1.0\\r\\n\")\n+        rfile.write(b\"Host: testserver\\r\\n\")\n+        rfile.write(b\"\\r\\n\")\n+        rfile.seek(0)\n+\n+        # WSGIRequestHandler closes the output file; we need to make this a\n+        # no-op so we can still read its contents.\n+        class UnclosableBytesIO(BytesIO):\n+            def close(self):\n+                pass\n+\n+        wfile = UnclosableBytesIO()\n+\n+        def makefile(mode, *a, **kw):\n+            if mode == \"rb\":\n+                return rfile\n+            elif mode == \"wb\":\n+                return wfile\n+\n+        request = Stub(makefile=makefile)\n+        server = Stub(base_environ={}, get_app=lambda: test_app)\n+\n+        # Prevent logging from appearing in test output.\n+        with self.assertLogs(\"django.server\", \"INFO\"):\n+            # instantiating a handler runs the request as side effect\n+            WSGIRequestHandler(request, \"192.168.0.2\", server)\n+\n+        wfile.seek(0)\n+        response_data = wfile.read()\n+        \n+        # Split headers and body\n+        response_str = response_data.decode('utf-8', errors='ignore')\n+        parts = response_str.split('\\r\\n\\r\\n', 1)\n+        headers = parts[0]\n+        body = parts[1] if len(parts) > 1 else \"\"\n+        \n+        # Verify we have headers\n+        self.assertIn(\"HTTP/1.1 200 OK\", headers)\n+        self.assertIn(\"Content-Type: text/html\", headers)\n+        \n+        # Verify body content for GET request\n+        self.assertIn(\"<!DOCTYPE html>\", body, \"GET request should return response body\")\n+        self.assertIn(\"Test Page\", body, \"GET request should return response body\")\n+\n \n class WSGIServerTestCase(SimpleTestCase):\n     request_factory = RequestFactory()\n"}