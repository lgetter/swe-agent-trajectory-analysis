{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-12713", "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 69a5fbf389..db7df891e3 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -249,16 +249,17 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n             return None\n         db = kwargs.get('using')\n \n-        autocomplete_fields = self.get_autocomplete_fields(request)\n-        if db_field.name in autocomplete_fields:\n-            kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\n-        elif db_field.name in self.raw_id_fields:\n-            kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n-        elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n-            kwargs['widget'] = widgets.FilteredSelectMultiple(\n-                db_field.verbose_name,\n-                db_field.name in self.filter_vertical\n-            )\n+        if 'widget' not in kwargs:\n+            autocomplete_fields = self.get_autocomplete_fields(request)\n+            if db_field.name in autocomplete_fields:\n+                kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\n+            elif db_field.name in self.raw_id_fields:\n+                kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n+            elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n+                kwargs['widget'] = widgets.FilteredSelectMultiple(\n+                    db_field.verbose_name,\n+                    db_field.name in self.filter_vertical\n+                )\n \n         if 'queryset' not in kwargs:\n             queryset = self.get_field_queryset(db, db_field, request)\ndiff --git a/tests/admin_widgets/tests.py b/tests/admin_widgets/tests.py\nindex 719d0d8095..4c3f6bdb85 100644\n--- a/tests/admin_widgets/tests.py\n+++ b/tests/admin_widgets/tests.py\n@@ -117,6 +117,28 @@ class AdminFormfieldForDBFieldTests(SimpleTestCase):\n         self.assertFormfield(Band, 'members', widgets.FilteredSelectMultiple,\n                              filter_vertical=['members'])\n \n+    def test_many_to_many_widget_override(self):\n+        \"\"\"\n+        Test that widget parameter is respected in formfield_for_manytomany\n+        even when field is in filter_horizontal, raw_id_fields, or autocomplete_fields.\n+        \"\"\"\n+        class MyModelAdmin(admin.ModelAdmin):\n+            filter_horizontal = ['members']\n+            raw_id_fields = ['members']\n+            autocomplete_fields = ['members']\n+\n+        ma = MyModelAdmin(Band, admin.site)\n+        field = Band._meta.get_field('members')\n+        \n+        # Test with custom widget - should override all field configurations\n+        custom_widget = forms.CheckboxSelectMultiple(attrs={'class': 'custom'})\n+        formfield = ma.formfield_for_manytomany(field, request=None, widget=custom_widget)\n+        \n+        # Widget type should be preserved\n+        self.assertIsInstance(formfield.widget, forms.CheckboxSelectMultiple)\n+        # Widget attributes should be preserved\n+        self.assertEqual(formfield.widget.attrs, {'class': 'custom'})\n+\n     def test_formfield_overrides(self):\n         self.assertFormfield(Event, 'start_date', forms.TextInput,\n                              formfield_overrides={DateField: {'widget': forms.TextInput}})\n"}