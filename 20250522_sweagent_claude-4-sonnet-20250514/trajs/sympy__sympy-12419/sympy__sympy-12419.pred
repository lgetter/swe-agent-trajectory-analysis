{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "sympy__sympy-12419", "model_patch": "diff --git a/sympy/concrete/summations.py b/sympy/concrete/summations.py\nindex 372487664c..80d5afcff0 100644\n--- a/sympy/concrete/summations.py\n+++ b/sympy/concrete/summations.py\n@@ -867,6 +867,34 @@ def eval_sum(f, limits):\n                 newargs.append((newexpr, arg.cond))\n             return f.func(*newargs)\n \n+    # Special case for Piecewise expressions where the condition matches the summation bounds\n+    if isinstance(f, Piecewise):\n+        # Check if we have a simple case like Piecewise((expr, (a <= i) & (i <= b)), (0, True))\n+        # where we're summing from a to b\n+        if len(f.args) == 2 and f.args[1].expr == 0 and f.args[1].cond == True:\n+            expr, cond = f.args[0]\n+            # Check if the condition is of the form (a <= i) & (i <= b)\n+            from sympy.logic.boolalg import And\n+            if isinstance(cond, And) and len(cond.args) == 2:\n+                from sympy.core.relational import LessThan\n+                left_cond, right_cond = cond.args\n+                # Check for (a <= i) & (i <= b) pattern\n+                # This can appear as either:\n+                # LessThan(a, i) & LessThan(i, b)  or  GreaterThan(i, a) & LessThan(i, b)\n+                from sympy.core.relational import GreaterThan\n+                \n+                # Check if we have the pattern (a <= i) & (i <= b)\n+                left_matches = ((isinstance(left_cond, LessThan) and \n+                                left_cond.lhs == a and left_cond.rhs == i) or\n+                               (isinstance(left_cond, GreaterThan) and \n+                                left_cond.lhs == i and left_cond.rhs == a))\n+                right_matches = (isinstance(right_cond, LessThan) and\n+                                right_cond.lhs == i and right_cond.rhs == b)\n+                \n+                if left_matches and right_matches:\n+                    # The condition matches the summation bounds, so we can simplify\n+                    return eval_sum(expr, limits)\n+\n     if f.has(KroneckerDelta) and _has_simple_delta(f, limits[0]):\n         return deltasummation(f, limits)\n \ndiff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py\nindex b4d759836e..d5c107844c 100644\n--- a/sympy/matrices/expressions/matexpr.py\n+++ b/sympy/matrices/expressions/matexpr.py\n@@ -476,10 +476,16 @@ def conjugate(self):\n         return self\n \n     def _entry(self, i, j):\n-        if i == j:\n-            return S.One\n-        else:\n-            return S.Zero\n+        from sympy.functions.special.tensor_functions import KroneckerDelta\n+        from sympy.core.relational import Eq\n+        # For concrete indices, use the simple comparison\n+        if i.is_number and j.is_number:\n+            if i == j:\n+                return S.One\n+            else:\n+                return S.Zero\n+        # For symbolic indices, use KroneckerDelta which handles summation better\n+        return KroneckerDelta(i, j)\n \n     def _eval_determinant(self):\n         return S.One\n"}