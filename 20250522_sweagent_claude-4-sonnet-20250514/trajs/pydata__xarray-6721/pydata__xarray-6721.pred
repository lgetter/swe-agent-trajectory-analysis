{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "pydata__xarray-6721", "model_patch": "diff --git a/xarray/core/common.py b/xarray/core/common.py\nindex 3c328f42..a37326f0 100644\n--- a/xarray/core/common.py\n+++ b/xarray/core/common.py\n@@ -2023,7 +2023,8 @@ def get_chunksizes(\n \n     chunks: dict[Any, tuple[int, ...]] = {}\n     for v in variables:\n-        if hasattr(v.data, \"chunks\"):\n+        # Check for dask chunks first (these take priority)\n+        if hasattr(v._data, \"chunks\"):\n             for dim, c in v.chunksizes.items():\n                 if dim in chunks and c != chunks[dim]:\n                     raise ValueError(\n@@ -2031,6 +2032,18 @@ def get_chunksizes(\n                         \"This can be fixed by calling unify_chunks().\"\n                     )\n                 chunks[dim] = c\n+        # Fall back to zarr chunks in encoding (without loading data)\n+        elif \"preferred_chunks\" in v.encoding:\n+            preferred_chunks = v.encoding[\"preferred_chunks\"]\n+            for dim in v.dims:\n+                if dim in preferred_chunks:\n+                    c = (preferred_chunks[dim],)\n+                    if dim in chunks and c != chunks[dim]:\n+                        raise ValueError(\n+                            f\"Object has inconsistent chunks along dimension {dim}. \"\n+                            \"This can be fixed by calling unify_chunks().\"\n+                        )\n+                    chunks[dim] = c\n     return Frozen(chunks)\n \n \ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 2d115ff0..a4b73cff 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -1014,10 +1014,17 @@ class Variable(AbstractArray, NdimSizeLenMixin, VariableArithmetic):\n         Variable.chunks\n         xarray.unify_chunks\n         \"\"\"\n+        # Check for dask chunks first\n         if hasattr(self._data, \"chunks\"):\n             return Frozen({dim: c for dim, c in zip(self.dims, self.data.chunks)})\n-        else:\n-            return {}\n+        \n+        # Check for zarr chunks in encoding (without loading data)\n+        if \"preferred_chunks\" in self.encoding:\n+            preferred_chunks = self.encoding[\"preferred_chunks\"]\n+            # Only return chunks for dimensions that exist in this variable\n+            return Frozen({dim: (preferred_chunks[dim],) for dim in self.dims if dim in preferred_chunks})\n+        \n+        return {}\n \n     _array_counter = itertools.count()\n \n"}