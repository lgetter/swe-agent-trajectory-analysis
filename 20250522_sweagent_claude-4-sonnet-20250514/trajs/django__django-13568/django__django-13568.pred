{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-13568", "model_patch": "diff --git a/django/contrib/auth/checks.py b/django/contrib/auth/checks.py\nindex 65fc266f7e..3c94d163a9 100644\n--- a/django/contrib/auth/checks.py\n+++ b/django/contrib/auth/checks.py\n@@ -4,10 +4,31 @@ from types import MethodType\n from django.apps import apps\n from django.conf import settings\n from django.core import checks\n+from django.db.models.constraints import UniqueConstraint\n \n from .management import _get_builtin_permissions\n \n \n+def _is_field_unique(cls, field_name):\n+    \"\"\"\n+    Check if a field is unique either through field.unique=True or through\n+    a UniqueConstraint that includes only this field.\n+    \"\"\"\n+    # Check if the field has unique=True\n+    field = cls._meta.get_field(field_name)\n+    if field.unique:\n+        return True\n+    \n+    # Check if there's a UniqueConstraint that makes this field unique\n+    for constraint in cls._meta.constraints:\n+        if (isinstance(constraint, UniqueConstraint) and \n+            constraint.fields == (field_name,) and \n+            constraint.condition is None):\n+            return True\n+    \n+    return False\n+\n+\n def check_user_model(app_configs=None, **kwargs):\n     if app_configs is None:\n         cls = apps.get_model(settings.AUTH_USER_MODEL)\n@@ -52,7 +73,7 @@ def check_user_model(app_configs=None, **kwargs):\n         )\n \n     # Check that the username field is unique\n-    if not cls._meta.get_field(cls.USERNAME_FIELD).unique:\n+    if not _is_field_unique(cls, cls.USERNAME_FIELD):\n         if (settings.AUTHENTICATION_BACKENDS ==\n                 ['django.contrib.auth.backends.ModelBackend']):\n             errors.append(\ndiff --git a/tests/auth_tests/test_checks.py b/tests/auth_tests/test_checks.py\nindex cfaa4063f8..b01557bf24 100644\n--- a/tests/auth_tests/test_checks.py\n+++ b/tests/auth_tests/test_checks.py\n@@ -4,6 +4,7 @@ from django.contrib.auth.checks import (\n from django.contrib.auth.models import AbstractBaseUser\n from django.core import checks\n from django.db import models\n+from django.db.models.constraints import UniqueConstraint\n from django.test import (\n     SimpleTestCase, override_settings, override_system_checks,\n )\n@@ -85,6 +86,79 @@ class UserModelChecksTests(SimpleTestCase):\n                 ),\n             ])\n \n+    @override_settings(AUTH_USER_MODEL='auth_tests.CustomUserUniqueConstraintUsername')\n+    def test_username_unique_constraint(self):\n+        \"\"\"\n+        A USERNAME_FIELD with a UniqueConstraint should not raise an error.\n+        \"\"\"\n+        class CustomUserUniqueConstraintUsername(AbstractBaseUser):\n+            username = models.CharField(max_length=30)\n+            USERNAME_FIELD = 'username'\n+\n+            class Meta:\n+                constraints = [\n+                    UniqueConstraint(fields=['username'], name='unique_username')\n+                ]\n+\n+        errors = checks.run_checks(app_configs=self.apps.get_app_configs())\n+        self.assertEqual(errors, [])\n+\n+    @override_settings(AUTH_USER_MODEL='auth_tests.CustomUserConditionalUniqueConstraint')\n+    def test_username_conditional_unique_constraint(self):\n+        \"\"\"\n+        A USERNAME_FIELD with a conditional UniqueConstraint should raise an error\n+        because the constraint doesn't guarantee uniqueness in all cases.\n+        \"\"\"\n+        class CustomUserConditionalUniqueConstraint(AbstractBaseUser):\n+            username = models.CharField(max_length=30)\n+            is_active = models.BooleanField(default=True)\n+            USERNAME_FIELD = 'username'\n+\n+            class Meta:\n+                constraints = [\n+                    UniqueConstraint(\n+                        fields=['username'], \n+                        name='unique_username',\n+                        condition=models.Q(is_active=True)\n+                    )\n+                ]\n+\n+        errors = checks.run_checks(app_configs=self.apps.get_app_configs())\n+        self.assertEqual(errors, [\n+            checks.Error(\n+                \"'CustomUserConditionalUniqueConstraint.username' must be \"\n+                \"unique because it is named as the 'USERNAME_FIELD'.\",\n+                obj=CustomUserConditionalUniqueConstraint,\n+                id='auth.E003',\n+            ),\n+        ])\n+\n+    @override_settings(AUTH_USER_MODEL='auth_tests.CustomUserMultiFieldUniqueConstraint')\n+    def test_username_multi_field_unique_constraint(self):\n+        \"\"\"\n+        A USERNAME_FIELD with a multi-field UniqueConstraint should raise an error\n+        because the constraint doesn't guarantee uniqueness of the username field alone.\n+        \"\"\"\n+        class CustomUserMultiFieldUniqueConstraint(AbstractBaseUser):\n+            username = models.CharField(max_length=30)\n+            email = models.EmailField()\n+            USERNAME_FIELD = 'username'\n+\n+            class Meta:\n+                constraints = [\n+                    UniqueConstraint(fields=['username', 'email'], name='unique_username_email')\n+                ]\n+\n+        errors = checks.run_checks(app_configs=self.apps.get_app_configs())\n+        self.assertEqual(errors, [\n+            checks.Error(\n+                \"'CustomUserMultiFieldUniqueConstraint.username' must be \"\n+                \"unique because it is named as the 'USERNAME_FIELD'.\",\n+                obj=CustomUserMultiFieldUniqueConstraint,\n+                id='auth.E003',\n+            ),\n+        ])\n+\n     @override_settings(AUTH_USER_MODEL='auth_tests.BadUser')\n     def test_is_anonymous_authenticated_methods(self):\n         \"\"\"\n"}