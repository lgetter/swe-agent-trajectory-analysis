{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-15554", "model_patch": "diff --git a/django/db/models/sql/datastructures.py b/django/db/models/sql/datastructures.py\nindex 1edf040e82..aaec79fe88 100644\n--- a/django/db/models/sql/datastructures.py\n+++ b/django/db/models/sql/datastructures.py\n@@ -162,7 +162,12 @@ class Join:\n         return hash(self.identity)\n \n     def equals(self, other):\n-        # Ignore filtered_relation in equality check.\n+        # If both joins have filtered_relation, include it in equality check.\n+        # This ensures that multiple FilteredRelation objects with different\n+        # conditions but same relation don't get reused.\n+        if self.filtered_relation is not None and other.filtered_relation is not None:\n+            return self.identity == other.identity\n+        # Otherwise, ignore filtered_relation in equality check.\n         return self.identity[:-1] == other.identity[:-1]\n \n     def demote(self):\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258eac..4b8173d3a5 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -804,14 +804,19 @@ class Query(BaseExpression):\n             return alias, False\n \n         # Create a new alias for this table.\n-        if alias_list:\n+        if filtered_relation is not None:\n+            # Always use the filtered relation's alias when provided\n+            alias = filtered_relation.alias\n+            if alias_list:\n+                alias_list.append(alias)\n+            else:\n+                self.table_map[table_name] = [alias]\n+        elif alias_list:\n             alias = \"%s%d\" % (self.alias_prefix, len(self.alias_map) + 1)\n             alias_list.append(alias)\n         else:\n             # The first occurrence of a table uses the table name directly.\n-            alias = (\n-                filtered_relation.alias if filtered_relation is not None else table_name\n-            )\n+            alias = table_name\n             self.table_map[table_name] = [alias]\n         self.alias_refcount[alias] = 1\n         return alias, True\ndiff --git a/tests/filtered_relation/tests.py b/tests/filtered_relation/tests.py\nindex 790a90d9e2..9a45c0c512 100644\n--- a/tests/filtered_relation/tests.py\n+++ b/tests/filtered_relation/tests.py\n@@ -164,6 +164,68 @@ class FilteredRelationTests(TestCase):\n             [self.author1, self.author2],\n         )\n \n+    def test_multiple_filtered_relations_different_conditions(self):\n+        \"\"\"\n+        Test that multiple FilteredRelation objects with different conditions\n+        but for the same relation create separate joins.\n+        \"\"\"\n+        qs = Author.objects.alias(\n+            available_books=FilteredRelation(\n+                \"book\",\n+                condition=Q(book__state=Book.AVAILABLE)\n+            ),\n+            rented_books=FilteredRelation(\n+                \"book\", \n+                condition=Q(book__state=Book.RENTED)\n+            )\n+        ).annotate(\n+            available_count=Count(\"available_books\"),\n+            rented_count=Count(\"rented_books\")\n+        )\n+        \n+        # Check that both aliases appear in the SQL\n+        sql_str = str(qs.query)\n+        self.assertIn('available_books', sql_str)\n+        self.assertIn('rented_books', sql_str)\n+        \n+        # Check that we have 2 JOIN clauses\n+        join_count = sql_str.upper().count('JOIN')\n+        self.assertEqual(join_count, 2)\n+\n+    def test_multiple_filtered_relations_with_case_when(self):\n+        \"\"\"\n+        Test the exact scenario from the PR description using Case/When.\n+        \"\"\"\n+        qs = Author.objects.alias(\n+            available_books=FilteredRelation(\n+                \"book\",\n+                condition=Q(book__state=Book.AVAILABLE)\n+            ),\n+            rented_books=FilteredRelation(\n+                \"book\", \n+                condition=Q(book__state=Book.RENTED)\n+            )\n+        ).annotate(\n+            available_title=F(\"available_books__title\"),\n+            rented_title=F(\"rented_books__title\"),\n+            final_title=Case(\n+                When(\n+                    available_title__isnull=True,\n+                    then=F(\"rented_title\"),\n+                ),\n+                default=F(\"available_title\")\n+            )\n+        )\n+        \n+        # Check that both aliases appear in the SQL\n+        sql_str = str(qs.query)\n+        self.assertIn('available_books', sql_str)\n+        self.assertIn('rented_books', sql_str)\n+        \n+        # Check that we have 2 JOIN clauses\n+        join_count = sql_str.upper().count('JOIN')\n+        self.assertEqual(join_count, 2)\n+\n     def test_with_join(self):\n         self.assertSequenceEqual(\n             Author.objects.annotate(\n"}