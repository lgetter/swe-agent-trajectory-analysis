{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "pylint-dev__pylint-8898", "model_patch": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd175..a8268b82b 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -111,10 +111,86 @@ def _regex_transformer(value: str) -> Pattern[str]:\n         raise argparse.ArgumentTypeError(msg) from e\n \n \n+def _regex_csv_split(value: str) -> Sequence[str]:\n+    \"\"\"Split a comma-separated string of regexes, handling commas inside regex patterns.\n+    \n+    This function is aware of regex syntax and won't split on commas that are inside\n+    braces (quantifiers like {1,3}) or other regex constructs.\n+    \"\"\"\n+    if not value.strip():\n+        return []\n+    \n+    patterns = []\n+    current_pattern = \"\"\n+    brace_depth = 0\n+    bracket_depth = 0\n+    paren_depth = 0\n+    in_char_class = False\n+    escaped = False\n+    \n+    i = 0\n+    while i < len(value):\n+        char = value[i]\n+        \n+        if escaped:\n+            # Previous character was a backslash, so this character is escaped\n+            current_pattern += char\n+            escaped = False\n+        elif char == '\\\\':\n+            # This is an escape character\n+            current_pattern += char\n+            escaped = True\n+        elif char == '[' and not in_char_class:\n+            # Start of character class\n+            current_pattern += char\n+            in_char_class = True\n+            bracket_depth += 1\n+        elif char == ']' and in_char_class and bracket_depth > 0:\n+            # End of character class\n+            current_pattern += char\n+            bracket_depth -= 1\n+            if bracket_depth == 0:\n+                in_char_class = False\n+        elif not in_char_class:\n+            # We're not inside a character class, so we can track other constructs\n+            if char == '{':\n+                brace_depth += 1\n+                current_pattern += char\n+            elif char == '}':\n+                brace_depth -= 1\n+                current_pattern += char\n+            elif char == '(':\n+                paren_depth += 1\n+                current_pattern += char\n+            elif char == ')':\n+                paren_depth -= 1\n+                current_pattern += char\n+            elif char == ',' and brace_depth == 0 and paren_depth == 0:\n+                # This comma is not inside braces or parentheses, so it's a separator\n+                pattern = current_pattern.strip()\n+                if pattern:\n+                    patterns.append(pattern)\n+                current_pattern = \"\"\n+            else:\n+                current_pattern += char\n+        else:\n+            # We're inside a character class, just add the character\n+            current_pattern += char\n+        \n+        i += 1\n+    \n+    # Add the last pattern\n+    pattern = current_pattern.strip()\n+    if pattern:\n+        patterns.append(pattern)\n+    \n+    return patterns\n+\n+\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _regex_csv_split(value):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \n@@ -122,7 +198,7 @@ def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _regex_csv_split(value):\n         patterns.append(\n             re.compile(\n                 str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n"}