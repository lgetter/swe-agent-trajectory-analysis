{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-13449", "model_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 90d90119d0..33756d596e 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1332,6 +1332,62 @@ class Window(Expression):\n             'window': ''.join(window_sql).strip()\n         }, params\n \n+    def as_sqlite(self, compiler, connection, **extra_context):\n+        # For SQLite, we need to handle DecimalField casting differently for window functions.\n+        # Instead of casting just the inner expression, we need to cast the entire window expression.\n+        connection.ops.check_expression_support(self)\n+        if not connection.features.supports_over_clause:\n+            raise NotSupportedError('This backend does not support window expressions.')\n+        \n+        # Compile the source expression without SQLite-specific casting\n+        # by temporarily calling as_sql instead of letting compiler.compile use as_sqlite\n+        if hasattr(self.source_expression, 'as_sql'):\n+            expr_sql, params = self.source_expression.as_sql(compiler, connection)\n+        else:\n+            expr_sql, params = compiler.compile(self.source_expression)\n+        \n+        window_sql, window_params = [], []\n+\n+        if self.partition_by is not None:\n+            sql_expr, sql_params = self.partition_by.as_sql(\n+                compiler=compiler, connection=connection,\n+                template='PARTITION BY %(expressions)s',\n+            )\n+            window_sql.extend(sql_expr)\n+            window_params.extend(sql_params)\n+\n+        if self.order_by is not None:\n+            window_sql.append(' ORDER BY ')\n+            # Use as_sql for order_by to avoid SQLite casting issues in ORDER BY clause\n+            if hasattr(self.order_by, 'as_sql'):\n+                order_sql, order_params = self.order_by.as_sql(compiler, connection)\n+            else:\n+                order_sql, order_params = compiler.compile(self.order_by)\n+            window_sql.extend(order_sql)\n+            window_params.extend(order_params)\n+\n+        if self.frame:\n+            frame_sql, frame_params = compiler.compile(self.frame)\n+            window_sql.append(' ' + frame_sql)\n+            window_params.extend(frame_params)\n+\n+        params.extend(window_params)\n+        template = self.template\n+\n+        window_expr_sql = template % {\n+            'expression': expr_sql,\n+            'window': ''.join(window_sql).strip()\n+        }\n+        \n+        # Apply SQLite decimal casting to the entire window expression if needed\n+        try:\n+            if self.output_field.get_internal_type() == 'DecimalField':\n+                window_expr_sql = 'CAST(%s AS NUMERIC)' % window_expr_sql\n+        except (AttributeError, FieldError):\n+            pass\n+        \n+        return window_expr_sql, params\n+\n     def __str__(self):\n         return '{} OVER ({}{}{})'.format(\n             str(self.source_expression),\ndiff --git a/tests/expressions_window/models.py b/tests/expressions_window/models.py\nindex ce6f6621e9..372edf2991 100644\n--- a/tests/expressions_window/models.py\n+++ b/tests/expressions_window/models.py\n@@ -12,3 +12,9 @@ class Employee(models.Model):\n     hire_date = models.DateField(blank=False, null=False)\n     age = models.IntegerField(blank=False, null=False)\n     classification = models.ForeignKey('Classification', on_delete=models.CASCADE, null=True)\n+\n+\n+class DecimalModel(models.Model):\n+    name = models.CharField(max_length=50)\n+    value = models.DecimalField(max_digits=10, decimal_places=2)\n+    date = models.DateField()\ndiff --git a/tests/expressions_window/tests.py b/tests/expressions_window/tests.py\nindex 30ed64f529..1bcb765379 100644\n--- a/tests/expressions_window/tests.py\n+++ b/tests/expressions_window/tests.py\n@@ -13,7 +13,7 @@ from django.db.models.functions import (\n )\n from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n \n-from .models import Employee\n+from .models import Employee, DecimalModel\n \n \n @skipUnlessDBFeature('supports_over_clause')\n@@ -786,6 +786,51 @@ class WindowFunctionTests(TestCase):\n                 frame=RowRange(start='a'),\n             )))\n \n+    @skipUnlessDBFeature('supports_over_clause')\n+    def test_lag_with_decimal_field_sqlite(self):\n+        \"\"\"\n+        Test that Lag() with DecimalField works correctly on SQLite.\n+        This is a regression test for the issue where CAST was applied\n+        to just the function instead of the entire window expression.\n+        \"\"\"\n+        from .models import DecimalModel\n+        from decimal import Decimal\n+        import datetime\n+        \n+        # Create test data\n+        DecimalModel.objects.bulk_create([\n+            DecimalModel(name='A', value=Decimal('10.50'), date=datetime.date(2023, 1, 1)),\n+            DecimalModel(name='B', value=Decimal('20.75'), date=datetime.date(2023, 1, 2)),\n+            DecimalModel(name='C', value=Decimal('30.25'), date=datetime.date(2023, 1, 3)),\n+        ])\n+        \n+        # Test Lag with DecimalField - this should not raise an OperationalError\n+        qs = DecimalModel.objects.annotate(\n+            prev_value=Window(\n+                expression=Lag('value', 1),\n+                order_by=F('date').asc()\n+            )\n+        ).order_by('date')\n+        \n+        # This should execute without error\n+        results = list(qs.values('name', 'value', 'prev_value'))\n+        \n+        # Verify the results\n+        expected = [\n+            {'name': 'A', 'value': Decimal('10.50'), 'prev_value': None},\n+            {'name': 'B', 'value': Decimal('20.75'), 'prev_value': Decimal('10.50')},\n+            {'name': 'C', 'value': Decimal('30.25'), 'prev_value': Decimal('20.75')},\n+        ]\n+        \n+        # Convert Decimal values for comparison (SQLite may return with different precision)\n+        for i, result in enumerate(results):\n+            if result['prev_value'] is not None:\n+                self.assertAlmostEqual(float(result['prev_value']), float(expected[i]['prev_value']), places=2)\n+            else:\n+                self.assertIsNone(expected[i]['prev_value'])\n+            self.assertEqual(result['name'], expected[i]['name'])\n+            self.assertAlmostEqual(float(result['value']), float(expected[i]['value']), places=2)\n+\n \n class WindowUnsupportedTests(TestCase):\n     def test_unsupported_backend(self):\n"}