{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "pytest-dev__pytest-7324", "model_patch": "diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex 04c73411a..80c08f388 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -129,7 +129,12 @@ class Scanner:\n \n def expression(s: Scanner) -> ast.Expression:\n     if s.accept(TokenType.EOF):\n-        ret = ast.NameConstant(False)  # type: ast.expr\n+        # For empty expressions, use ast.NameConstant for compatibility\n+        # This is safe because it's not a user-provided identifier\n+        if hasattr(ast, 'Constant'):\n+            ret = ast.Constant(False)  # type: ast.expr\n+        else:\n+            ret = ast.NameConstant(False)  # type: ast.expr\n     else:\n         ret = expr(s)\n         s.accept(TokenType.EOF, reject=True)\n@@ -161,7 +166,13 @@ def not_expr(s: Scanner) -> ast.expr:\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n-        return ast.Name(ident.value, ast.Load())\n+        # Handle special constants that can't be used with ast.Name in Python 3.8+\n+        # We use a prefix to make them safe for the AST compiler, and the MatcherAdapter\n+        # will handle the mapping back to the original names\n+        if ident.value in (\"True\", \"False\", \"None\"):\n+            return ast.Name(\"__pytest_\" + ident.value, ast.Load())\n+        else:\n+            return ast.Name(ident.value, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n \n@@ -172,6 +183,11 @@ class MatcherAdapter(Mapping[str, bool]):\n         self.matcher = matcher\n \n     def __getitem__(self, key: str) -> bool:\n+        # Handle the special prefixed names for True, False, None\n+        if key.startswith(\"__pytest_\"):\n+            original_key = key[9:]  # Remove the \"__pytest_\" prefix\n+            if original_key in (\"True\", \"False\", \"None\"):\n+                return self.matcher(original_key)\n         return self.matcher(key)\n \n     def __iter__(self) -> Iterator[str]:\n"}