{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "sphinx-doc__sphinx-11510", "model_patch": "diff --git a/sphinx/directives/other.py b/sphinx/directives/other.py\nindex 19f7c0a8d..160ce1886 100644\n--- a/sphinx/directives/other.py\n+++ b/sphinx/directives/other.py\n@@ -1,9 +1,10 @@\n from __future__ import annotations\n \n import re\n+from pathlib import Path\n from typing import TYPE_CHECKING, Any, cast\n \n-from docutils import nodes\n+from docutils import io, nodes, statemachine, utils\n from docutils.parsers.rst import directives\n from docutils.parsers.rst.directives.admonitions import BaseAdmonition\n from docutils.parsers.rst.directives.misc import Class\n@@ -376,7 +377,183 @@ class Include(BaseInclude, SphinxDirective):\n         rel_filename, filename = self.env.relfn2path(self.arguments[0])\n         self.arguments[0] = filename\n         self.env.note_included(filename)\n-        return super().run()\n+        \n+        # Check if this is a Sphinx document that should be processed with source-read event\n+        if self._should_process_with_source_read(rel_filename):\n+            return self._run_with_source_read(rel_filename, filename)\n+        else:\n+            return super().run()\n+    \n+    def _should_process_with_source_read(self, rel_filename: str) -> bool:\n+        \"\"\"Check if the included file should be processed with source-read event.\"\"\"\n+        # Only process files that are in the source directory and have a known source suffix\n+        try:\n+            # Convert relative filename to docname\n+            docname = self.env.path2doc(rel_filename)\n+            return docname is not None\n+        except Exception:\n+            return False\n+    \n+    def _run_with_source_read(self, rel_filename: str, filename: str) -> list[Node]:\n+        \"\"\"Run the include directive with source-read event processing.\"\"\"\n+        # This is a modified version of docutils Include.run() that applies source-read event\n+        \n+        if not self.state.document.settings.file_insertion_enabled:\n+            raise self.warning('\"%s\" directive disabled.' % self.name)\n+        \n+        path = filename\n+        encoding = self.options.get(\n+            'encoding', self.state.document.settings.input_encoding)\n+        e_handler = self.state.document.settings.input_encoding_error_handler\n+        tab_width = self.options.get(\n+            'tab-width', self.state.document.settings.tab_width)\n+        \n+        try:\n+            include_file = io.FileInput(source_path=path,\n+                                        encoding=encoding,\n+                                        error_handler=e_handler)\n+        except UnicodeEncodeError:\n+            raise self.severe(f'Problems with \"{self.name}\" directive path:\\n'\n+                              f'Cannot encode input file path \"{path}\" '\n+                              '(wrong locale?).')\n+        except OSError as error:\n+            raise self.severe(f'Problems with \"{self.name}\" directive '\n+                              f'path:\\n{io.error_string(error)}.')\n+        else:\n+            self.state.document.settings.record_dependencies.add(path)\n+\n+        # Get to-be-included content\n+        startline = self.options.get('start-line', None)\n+        endline = self.options.get('end-line', None)\n+        try:\n+            if startline or (endline is not None):\n+                lines = include_file.readlines()\n+                rawtext = ''.join(lines[startline:endline])\n+            else:\n+                rawtext = include_file.read()\n+        except UnicodeError as error:\n+            raise self.severe(f'Problem with \"{self.name}\" directive:\\n'\n+                              + io.error_string(error))\n+        \n+        # Apply source-read event to the included content\n+        docname = self.env.path2doc(rel_filename)\n+        if docname:\n+            # Create a list with the content so it can be modified by the event\n+            source = [rawtext]\n+            # Emit the source-read event\n+            self.env.events.emit('source-read', docname, source)\n+            # Use the potentially modified content\n+            rawtext = source[0]\n+        \n+        # Continue with the rest of the processing (start-after/end-before, etc.)\n+        after_text = self.options.get('start-after', None)\n+        if after_text:\n+            # skip content in rawtext before *and incl.* a matching text\n+            after_index = rawtext.find(after_text)\n+            if after_index < 0:\n+                raise self.severe('Problem with \"start-after\" option of \"%s\" '\n+                                  'directive:\\nText not found.' % self.name)\n+            rawtext = rawtext[after_index + len(after_text):]\n+        before_text = self.options.get('end-before', None)\n+        if before_text:\n+            # skip content in rawtext after *and incl.* a matching text\n+            before_index = rawtext.find(before_text)\n+            if before_index < 0:\n+                raise self.severe('Problem with \"end-before\" option of \"%s\" '\n+                                  'directive:\\nText not found.' % self.name)\n+            rawtext = rawtext[:before_index]\n+\n+        include_lines = statemachine.string2lines(rawtext, tab_width,\n+                                                  convert_whitespace=True)\n+        for i, line in enumerate(include_lines):\n+            if len(line) > self.state.document.settings.line_length_limit:\n+                raise self.warning('\"%s\": line %d exceeds the'\n+                                   ' line-length-limit.' % (path, i+1))\n+\n+        if 'literal' in self.options:\n+            # Don't convert tabs to spaces, if `tab_width` is negative.\n+            if tab_width >= 0:\n+                text = rawtext.expandtabs(tab_width)\n+            else:\n+                text = rawtext\n+            literal_block = nodes.literal_block(\n+                                rawtext, source=path,\n+                                classes=self.options.get('class', []))\n+            literal_block.line = 1\n+            self.add_name(literal_block)\n+            if 'number-lines' in self.options:\n+                try:\n+                    startline = int(self.options['number-lines'] or 1)\n+                except ValueError:\n+                    raise self.error(':number-lines: with non-integer '\n+                                     'start value')\n+                endline = startline + len(include_lines)\n+                if text.endswith('\\n'):\n+                    text = text[:-1]\n+                # Import NumberLines here to avoid circular import\n+                from docutils.parsers.rst.directives.body import NumberLines\n+                tokens = NumberLines([([], text)], startline, endline)\n+                for classes, value in tokens:\n+                    if classes:\n+                        literal_block += nodes.inline(value, value,\n+                                                      classes=classes)\n+                    else:\n+                        literal_block += nodes.Text(value)\n+            else:\n+                literal_block += nodes.Text(text)\n+            return [literal_block]\n+\n+        if 'code' in self.options:\n+            self.options['source'] = path\n+            # Don't convert tabs to spaces, if `tab_width` is negative:\n+            if tab_width < 0:\n+                include_lines = rawtext.splitlines()\n+            # Import CodeBlock here to avoid circular import\n+            from docutils.parsers.rst.directives.body import CodeBlock\n+            codeblock = CodeBlock(self.name,\n+                                  [self.options.pop('code')],  # arguments\n+                                  self.options,\n+                                  include_lines,  # content\n+                                  self.lineno,\n+                                  self.content_offset,\n+                                  self.block_text,\n+                                  self.state,\n+                                  self.state_machine)\n+            return codeblock.run()\n+\n+        # Prevent circular inclusion:\n+        current_source = self.state.document.current_source\n+        clip_options = (startline, endline, before_text, after_text)\n+        include_log = self.state.document.include_log\n+        # log entries are tuples (<source>, <clip-options>)\n+        if not include_log:  # new document, initialize with document source\n+            include_log.append((utils.relative_path(None, current_source),\n+                                (None, None, None, None)))\n+        if (path, clip_options) in include_log:\n+            master_paths = (pth for (pth, opt) in reversed(include_log))\n+            inclusion_chain = '\\n> '.join((path, *master_paths))\n+            raise self.warning('circular inclusion in \"%s\" directive:\\n%s'\n+                               % (self.name, inclusion_chain))\n+\n+        if 'parser' in self.options:\n+            # parse into a dummy document and return created nodes\n+            document = utils.new_document(path, self.state.document.settings)\n+            document.include_log = include_log + [(path, clip_options)]\n+            parser = self.options['parser']()\n+            parser.parse('\\n'.join(include_lines), document)\n+            # clean up doctree and complete parsing\n+            document.transformer.populate_from_components((parser,))\n+            document.transformer.apply_transforms()\n+            return document.children\n+\n+        # Include as rST source:\n+        #\n+        # mark end (cf. parsers.rst.states.Body.comment())\n+        include_lines += ['', '.. end of inclusion from \"%s\"' % path]\n+        self.state_machine.insert_input(include_lines, path)\n+        # update include-log\n+        include_log.append((path, clip_options))\n+        return []\n \n \n def setup(app: Sphinx) -> dict[str, Any]:\ndiff --git a/tox.ini b/tox.ini\nindex a3dc56211..c76147de3 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -24,7 +24,7 @@ setenv =\n     PYTHONWARNINGS = error\n     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes\n commands=\n-    python -X dev -X warn_default_encoding -m pytest --durations 25 {posargs}\n+    python -X dev -X warn_default_encoding -m pytest -rA --durations 25 {posargs}\n \n [testenv:docs]\n basepython = python3\n"}