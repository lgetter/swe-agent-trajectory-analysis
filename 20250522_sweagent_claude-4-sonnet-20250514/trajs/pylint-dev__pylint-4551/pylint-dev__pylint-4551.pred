{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "pylint-dev__pylint-4551", "model_patch": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex bf9f67af6..8684edc52 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -119,6 +119,10 @@ class ClassDiagram(Figure, FilterMixIn):\n         \"\"\"return class names if needed in diagram\"\"\"\n         names = []\n         for node in nodes:\n+            # Skip uninferable nodes\n+            if node is astroid.Uninferable:\n+                continue\n+                \n             if isinstance(node, astroid.Instance):\n                 node = node._proxied\n             if (\n@@ -129,6 +133,20 @@ class ClassDiagram(Figure, FilterMixIn):\n                 if node.name not in names:\n                     node_name = node.name\n                     names.append(node_name)\n+            # Handle simple type annotation nodes (like str, int, etc.)\n+            elif isinstance(node, astroid.Name) and hasattr(node, \"name\"):\n+                if node.name not in names:\n+                    names.append(node.name)\n+            # Handle complex type annotation nodes (like List[str], Optional[str], etc.)\n+            # Only apply as_string() to nodes that are likely to be type annotations\n+            elif isinstance(node, (astroid.Subscript, astroid.Attribute)):\n+                try:\n+                    type_str = node.as_string()\n+                    if type_str not in names:\n+                        names.append(type_str)\n+                except Exception:\n+                    # If as_string() fails, skip this node\n+                    pass\n         return names\n \n     def nodes(self):\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 8fa122022..85ecde72e 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -231,11 +231,72 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         \"\"\"\n         try:\n             values = set(node.infer())\n+            \n+            # Check if this is an assignment in __init__ method and if there's a type hint\n+            type_hint_node = Linker._get_type_hint_for_assignattr(node, parent)\n+            if type_hint_node:\n+                # If we have a type hint, prefer it over inferred types\n+                # This handles cases like `a: str = None` where we want to show `str` not `NoneType`\n+                values = {type_hint_node}\n+            \n             current = set(parent.instance_attrs_type[node.attrname])\n             parent.instance_attrs_type[node.attrname] = list(current | values)\n         except astroid.InferenceError:\n             pass\n \n+    @staticmethod\n+    def _get_type_hint_for_assignattr(node, parent):\n+        \"\"\"Get type hint for an assignment attribute if available.\n+        \n+        This method checks if the assignment is in an __init__ method and if\n+        the assigned value comes from a parameter with a type annotation.\n+        \n+        Args:\n+            node: astroid.AssignAttr node representing the assignment\n+            parent: astroid.ClassDef node representing the class\n+            \n+        Returns:\n+            astroid node representing the type hint, or None if no hint found\n+        \"\"\"\n+        # Check if this assignment is in an __init__ method\n+        assign_node = node.parent\n+        if not isinstance(assign_node, astroid.Assign):\n+            return None\n+            \n+        # Get the function containing this assignment\n+        func_node = assign_node.frame()\n+        if not isinstance(func_node, astroid.FunctionDef) or func_node.name != '__init__':\n+            return None\n+            \n+        # Check if the assigned value is a simple name (parameter)\n+        if not isinstance(assign_node.value, astroid.Name):\n+            return None\n+            \n+        param_name = assign_node.value.name\n+        \n+        # Look for the parameter in the function arguments\n+        args = func_node.args\n+        if not args.args:\n+            return None\n+            \n+        # Find the parameter index\n+        param_index = None\n+        for i, arg in enumerate(args.args):\n+            if arg.name == param_name:\n+                param_index = i\n+                break\n+                \n+        if param_index is None:\n+            return None\n+            \n+        # Check if there's an annotation for this parameter\n+        if (args.annotations and \n+            param_index < len(args.annotations) and \n+            args.annotations[param_index] is not None):\n+            return args.annotations[param_index]\n+            \n+        return None\n+\n     def visit_import(self, node):\n         \"\"\"visit an astroid.Import node\n \n"}