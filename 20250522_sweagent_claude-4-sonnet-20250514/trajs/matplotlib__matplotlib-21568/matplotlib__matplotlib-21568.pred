{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "matplotlib__matplotlib-21568", "model_patch": "diff --git a/check_test_expectations.py b/check_test_expectations.py\nnew file mode 100644\nindex 0000000000..531562940c\n--- /dev/null\n+++ b/check_test_expectations.py\n@@ -0,0 +1,30 @@\n+import matplotlib.dates as mdates\n+import datetime\n+\n+# Test the exact cases from the test\n+test_cases = [\n+    (datetime.timedelta(weeks=52 * 200), \"years\"),\n+    (datetime.timedelta(days=30), \"days\"),\n+    (datetime.timedelta(hours=20), \"hours\"),\n+]\n+\n+for delta, desc in test_cases:\n+    print(f\"\\nTesting {desc} (delta={delta}):\")\n+    d1 = datetime.datetime(1990, 1, 1)\n+    d2 = d1 + delta\n+\n+    locator = mdates.AutoDateLocator(interval_multiples=False)\n+    locator.create_dummy_axis()\n+    locator.axis.set_view_interval(mdates.date2num(d1), mdates.date2num(d2))\n+\n+    formatter = mdates.AutoDateFormatter(locator, usetex=True)\n+    locations = locator()\n+    formatted = [formatter(loc) for loc in locations]\n+    \n+    print(f\"  Locations: {len(locations)}\")\n+    for i, (loc, fmt) in enumerate(zip(locations, formatted)):\n+        date = mdates.num2date(loc)\n+        print(f\"    {i}: {date} -> '{fmt}'\")\n+        if i >= 5:  # Limit output\n+            print(f\"    ... and {len(locations) - i - 1} more\")\n+            break\n\\ No newline at end of file\ndiff --git a/debug_datetime_tex.py b/debug_datetime_tex.py\nnew file mode 100644\nindex 0000000000..4113d65dc4\n--- /dev/null\n+++ b/debug_datetime_tex.py\n@@ -0,0 +1,58 @@\n+import matplotlib.dates as mdates\n+import datetime\n+\n+# Test the _wrap_in_tex function directly\n+from matplotlib.dates import _wrap_in_tex\n+\n+# Test cases from the failing tests\n+test_cases = [\n+    \"Jan 01 1990\",\n+    \"01:00:00\", \n+    \"01 00:00\",\n+    \"01 00:05\",\n+    \"01 00:10\",\n+    \"2020\",\n+    \"Feb\",\n+    \"12:30\"\n+]\n+\n+print(\"Testing _wrap_in_tex function:\")\n+for case in test_cases:\n+    result = _wrap_in_tex(case)\n+    print(f\"'{case}' -> '{result}'\")\n+\n+print(\"\\nTesting AutoDateFormatter with usetex:\")\n+# Test AutoDateFormatter\n+d1 = datetime.datetime(1990, 1, 1)\n+d2 = d1 + datetime.timedelta(days=30)\n+\n+locator = mdates.AutoDateLocator(interval_multiples=False)\n+locator.create_dummy_axis()\n+locator.axis.set_view_interval(mdates.date2num(d1), mdates.date2num(d2))\n+\n+formatter = mdates.AutoDateFormatter(locator, usetex=True)\n+locations = locator()\n+formatted = [formatter(loc) for loc in locations]\n+\n+print(\"Locations and formatted values:\")\n+for loc, fmt in zip(locations, formatted):\n+    date = mdates.num2date(loc)\n+    print(f\"  {date} -> '{fmt}'\")\n+\n+print(\"\\nTesting ConciseDateFormatter with usetex:\")\n+# Test ConciseDateFormatter  \n+d1 = datetime.datetime(2020, 1, 1, 0, 0, 0)\n+d2 = d1 + datetime.timedelta(minutes=10)\n+\n+locator = mdates.AutoDateLocator(interval_multiples=True)\n+locator.create_dummy_axis()\n+locator.axis.set_view_interval(mdates.date2num(d1), mdates.date2num(d2))\n+\n+formatter = mdates.ConciseDateFormatter(locator, usetex=True)\n+locations = locator()\n+formatted = formatter.format_ticks(locations)\n+\n+print(\"Locations and formatted values:\")\n+for loc, fmt in zip(locations, formatted):\n+    date = mdates.num2date(loc)\n+    print(f\"  {date} -> '{fmt}'\")\n\\ No newline at end of file\ndiff --git a/debug_pytest.py b/debug_pytest.py\nnew file mode 100644\nindex 0000000000..650140db66\n--- /dev/null\n+++ b/debug_pytest.py\n@@ -0,0 +1,53 @@\n+import matplotlib.dates as mdates\n+import datetime\n+import pytest\n+\n+@pytest.mark.parametrize('delta, expected', [\n+    (datetime.timedelta(weeks=52 * 200),\n+     [r'$\\mathdefault{%d}$' % (year,) for year in range(1990, 2171, 20)]),\n+    (datetime.timedelta(days=30),\n+     [r'Jan$\\mathdefault{ %02d 1990}$' % (day,) for day in range(1, 32, 3)]),\n+    (datetime.timedelta(hours=20),\n+     [r'$\\mathdefault{%02d:00:00}$' % (hour,) for hour in range(0, 21, 2)]),\n+])\n+def test_date_formatter_usetex_debug(delta, expected):\n+    d1 = datetime.datetime(1990, 1, 1)\n+    d2 = d1 + delta\n+\n+    locator = mdates.AutoDateLocator(interval_multiples=False)\n+    locator.create_dummy_axis()\n+    locator.axis.set_view_interval(mdates.date2num(d1), mdates.date2num(d2))\n+\n+    formatter = mdates.AutoDateFormatter(locator, usetex=True)\n+    actual = [formatter(loc) for loc in locator()]\n+    \n+    print(f\"\\nDelta: {delta}\")\n+    print(f\"Expected length: {len(expected)}\")\n+    print(f\"Actual length: {len(actual)}\")\n+    print(f\"Expected[0]: '{expected[0] if expected else 'N/A'}'\")\n+    print(f\"Actual[0]: '{actual[0] if actual else 'N/A'}'\")\n+    print(f\"Match: {actual == expected}\")\n+    \n+    assert actual == expected\n+\n+if __name__ == \"__main__\":\n+    # Run the test manually\n+    test_cases = [\n+        (datetime.timedelta(weeks=52 * 200),\n+         [r'$\\mathdefault{%d}$' % (year,) for year in range(1990, 2171, 20)]),\n+        (datetime.timedelta(days=30),\n+         [r'Jan$\\mathdefault{ %02d 1990}$' % (day,) for day in range(1, 32, 3)]),\n+        (datetime.timedelta(hours=20),\n+         [r'$\\mathdefault{%02d:00:00}$' % (hour,) for hour in range(0, 21, 2)]),\n+    ]\n+    \n+    for i, (delta, expected) in enumerate(test_cases):\n+        print(f\"\\n{'='*50}\")\n+        print(f\"Test case {i}: {delta}\")\n+        try:\n+            test_date_formatter_usetex_debug(delta, expected)\n+            print(\"PASSED\")\n+        except AssertionError as e:\n+            print(f\"FAILED: {e}\")\n+        except Exception as e:\n+            print(f\"ERROR: {e}\")\n\\ No newline at end of file\ndiff --git a/debug_pytest_env.py b/debug_pytest_env.py\nnew file mode 100644\nindex 0000000000..a14e4fed78\n--- /dev/null\n+++ b/debug_pytest_env.py\n@@ -0,0 +1,53 @@\n+#!/usr/bin/env python\n+\n+# Try to replicate the exact pytest environment\n+import sys\n+import os\n+\n+# Add the lib directory to the path (same as pytest)\n+sys.path.insert(0, os.path.join(os.getcwd(), 'lib'))\n+\n+# Import matplotlib and set up the same way as pytest\n+import matplotlib\n+matplotlib.use('agg', force=True)\n+matplotlib._called_from_pytest = True\n+matplotlib._init_tests()\n+\n+# Now import the test modules\n+import matplotlib.dates as mdates\n+import datetime\n+\n+# Run the test\n+def test_date_formatter_usetex(delta, expected):\n+    d1 = datetime.datetime(1990, 1, 1)\n+    d2 = d1 + delta\n+\n+    locator = mdates.AutoDateLocator(interval_multiples=False)\n+    locator.create_dummy_axis()\n+    locator.axis.set_view_interval(mdates.date2num(d1), mdates.date2num(d2))\n+\n+    formatter = mdates.AutoDateFormatter(locator, usetex=True)\n+    actual = [formatter(loc) for loc in locator()]\n+    \n+    print(f\"Delta: {delta}\")\n+    print(f\"Expected: {expected[:3]}...\")\n+    print(f\"Actual: {actual[:3]}...\")\n+    print(f\"Match: {actual == expected}\")\n+    \n+    return actual == expected\n+\n+# Test the failing case\n+delta = datetime.timedelta(days=30)\n+expected = [r'Jan$\\mathdefault{ %02d 1990}$' % (day,) for day in range(1, 32, 3)]\n+\n+print(\"Testing with pytest-like environment:\")\n+result = test_date_formatter_usetex(delta, expected)\n+print(f\"Test result: {result}\")\n+\n+# Also test the hours case\n+delta2 = datetime.timedelta(hours=20)\n+expected2 = [r'$\\mathdefault{%02d:00:00}$' % (hour,) for hour in range(0, 21, 2)]\n+\n+print(\"\\nTesting hours case:\")\n+result2 = test_date_formatter_usetex(delta2, expected2)\n+print(f\"Test result: {result2}\")\n\\ No newline at end of file\ndiff --git a/debug_rcparams.py b/debug_rcparams.py\nnew file mode 100644\nindex 0000000000..52a3271fcd\n--- /dev/null\n+++ b/debug_rcparams.py\n@@ -0,0 +1,52 @@\n+import matplotlib\n+import matplotlib.dates as mdates\n+import datetime\n+\n+# Check current rcParams\n+print(\"Current date.autoformatter rcParams:\")\n+for key in matplotlib.rcParams:\n+    if 'date.autoformatter' in key:\n+        print(f\"  {key}: {matplotlib.rcParams[key]}\")\n+\n+print(\"\\nTesting AutoDateFormatter behavior:\")\n+\n+# Test case: 30 days\n+delta = datetime.timedelta(days=30)\n+d1 = datetime.datetime(1990, 1, 1)\n+d2 = d1 + delta\n+\n+locator = mdates.AutoDateLocator(interval_multiples=False)\n+locator.create_dummy_axis()\n+locator.axis.set_view_interval(mdates.date2num(d1), mdates.date2num(d2))\n+\n+formatter = mdates.AutoDateFormatter(locator, usetex=True)\n+\n+# Check what scale the formatter is using\n+print(f\"Locator scale: {locator._get_unit()}\")\n+\n+# Check the formatter's format strings\n+print(f\"Formatter formats: {formatter.scaled}\")\n+\n+# Get the actual formatted values\n+locations = locator()\n+actual = [formatter(loc) for loc in locations]\n+\n+print(f\"\\nFirst few formatted values:\")\n+for i, (loc, fmt) in enumerate(zip(locations[:5], actual[:5])):\n+    date = mdates.num2date(loc)\n+    print(f\"  {i}: {date} -> '{fmt}'\")\n+\n+# Test with different rcParams\n+print(\"\\n\" + \"=\"*50)\n+print(\"Testing with modified rcParams:\")\n+\n+# Set rcParams to match what the test might expect\n+matplotlib.rcParams['date.autoformatter.day'] = '%b %d %Y'\n+\n+formatter2 = mdates.AutoDateFormatter(locator, usetex=True)\n+actual2 = [formatter2(loc) for loc in locations]\n+\n+print(f\"With modified rcParams:\")\n+for i, (loc, fmt) in enumerate(zip(locations[:5], actual2[:5])):\n+    date = mdates.num2date(loc)\n+    print(f\"  {i}: {date} -> '{fmt}'\")\n\\ No newline at end of file\ndiff --git a/debug_test_failure.py b/debug_test_failure.py\nnew file mode 100644\nindex 0000000000..bd458d302b\n--- /dev/null\n+++ b/debug_test_failure.py\n@@ -0,0 +1,39 @@\n+import matplotlib.dates as mdates\n+import datetime\n+\n+# Test the exact case that should produce \"Jan 01 1990\" format\n+delta = datetime.timedelta(days=30)\n+expected = [r'Jan$\\mathdefault{ %02d 1990}$' % (day,) for day in range(1, 32, 3)]\n+\n+print(\"Expected values:\")\n+for i, exp in enumerate(expected):\n+    print(f\"  {i}: '{exp}'\")\n+\n+d1 = datetime.datetime(1990, 1, 1)\n+d2 = d1 + delta\n+\n+locator = mdates.AutoDateLocator(interval_multiples=False)\n+locator.create_dummy_axis()\n+locator.axis.set_view_interval(mdates.date2num(d1), mdates.date2num(d2))\n+\n+formatter = mdates.AutoDateFormatter(locator, usetex=True)\n+locations = locator()\n+actual = [formatter(loc) for loc in locations]\n+\n+print(f\"\\nActual values (got {len(actual)} vs expected {len(expected)}):\")\n+for i, act in enumerate(actual):\n+    print(f\"  {i}: '{act}'\")\n+\n+print(f\"\\nComparison:\")\n+for i, (exp, act) in enumerate(zip(expected, actual)):\n+    match = exp == act\n+    print(f\"  {i}: {'\u2713' if match else '\u2717'} Expected: '{exp}' | Actual: '{act}'\")\n+\n+# Let's also check what the locator is producing\n+print(f\"\\nLocator details:\")\n+print(f\"  Interval: {mdates.num2date(locator.axis.get_view_interval()[0])} to {mdates.num2date(locator.axis.get_view_interval()[1])}\")\n+print(f\"  Locations: {[mdates.num2date(loc) for loc in locations]}\")\n+\n+# Check the formatter's scale\n+print(f\"\\nFormatter scale: {formatter._formatter.scale}\")\n+print(f\"Formatter format: {formatter._formatter.format}\")\n\\ No newline at end of file\ndiff --git a/lib/matplotlib/dates.py b/lib/matplotlib/dates.py\nindex 0766156d64..df1a12be3b 100644\n--- a/lib/matplotlib/dates.py\n+++ b/lib/matplotlib/dates.py\n@@ -598,6 +598,17 @@ def _wrap_in_tex(text):\n     # Braces ensure dashes are not spaced like binary operators.\n     ret_text = '$\\\\mathdefault{'+ret_text.replace('-', '{-}')+'}$'\n     ret_text = ret_text.replace('$\\\\mathdefault{}$', '')\n+    \n+    # Fix spacing in math mode by replacing spaces with explicit LaTeX spacing\n+    # Replace spaces inside \\mathdefault{...} with \\  (explicit space)\n+    def replace_spaces_in_mathdefault(match):\n+        content = match.group(1)\n+        # Replace spaces with explicit LaTeX spaces\n+        content_with_spaces = content.replace(' ', r'\\ ')\n+        return f'$\\\\mathdefault{{{content_with_spaces}}}$'\n+    \n+    ret_text = re.sub(r'\\$\\\\mathdefault\\{([^}]*)\\}\\$', replace_spaces_in_mathdefault, ret_text)\n+    \n     return ret_text\n \n \ndiff --git a/manual_test_debug.py b/manual_test_debug.py\nnew file mode 100644\nindex 0000000000..1f62b91d1e\n--- /dev/null\n+++ b/manual_test_debug.py\n@@ -0,0 +1,61 @@\n+import matplotlib.dates as mdates\n+import datetime\n+\n+# Test case 2: days\n+delta = datetime.timedelta(days=30)\n+expected = [r'Jan$\\mathdefault{ %02d 1990}$' % (day,) for day in range(1, 32, 3)]\n+\n+d1 = datetime.datetime(1990, 1, 1)\n+d2 = d1 + delta\n+\n+locator = mdates.AutoDateLocator(interval_multiples=False)\n+locator.create_dummy_axis()\n+locator.axis.set_view_interval(mdates.date2num(d1), mdates.date2num(d2))\n+\n+formatter = mdates.AutoDateFormatter(locator, usetex=True)\n+actual = [formatter(loc) for loc in locator()]\n+\n+print(\"Expected length:\", len(expected))\n+print(\"Actual length:\", len(actual))\n+print()\n+\n+print(\"Expected first few:\")\n+for i in range(min(5, len(expected))):\n+    print(f\"  {i}: '{expected[i]}'\")\n+\n+print(\"\\nActual first few:\")\n+for i in range(min(5, len(actual))):\n+    print(f\"  {i}: '{actual[i]}'\")\n+\n+print(f\"\\nTest result: {actual == expected}\")\n+\n+# Let's also test the hours case\n+print(\"\\n\" + \"=\"*50)\n+print(\"Testing hours case:\")\n+\n+delta = datetime.timedelta(hours=20)\n+expected = [r'$\\mathdefault{%02d:00:00}$' % (hour,) for hour in range(0, 21, 2)]\n+\n+d1 = datetime.datetime(1990, 1, 1)\n+d2 = d1 + delta\n+\n+locator = mdates.AutoDateLocator(interval_multiples=False)\n+locator.create_dummy_axis()\n+locator.axis.set_view_interval(mdates.date2num(d1), mdates.date2num(d2))\n+\n+formatter = mdates.AutoDateFormatter(locator, usetex=True)\n+actual = [formatter(loc) for loc in locator()]\n+\n+print(\"Expected length:\", len(expected))\n+print(\"Actual length:\", len(actual))\n+print()\n+\n+print(\"Expected first few:\")\n+for i in range(min(5, len(expected))):\n+    print(f\"  {i}: '{expected[i]}'\")\n+\n+print(\"\\nActual first few:\")\n+for i in range(min(5, len(actual))):\n+    print(f\"  {i}: '{actual[i]}'\")\n+\n+print(f\"\\nTest result: {actual == expected}\")\n\\ No newline at end of file\ndiff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 0000000000..ff3f4cd5c9\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,16 @@\n+import matplotlib\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import pandas as pd\n+\n+np.random.seed(1)\n+matplotlib.rcParams[\"text.usetex\"] = True\n+\n+dates = pd.date_range(\"2020-01-01 00:00:00\", end=\"2020-01-01 00:10:00\", periods=100)\n+data = np.random.rand(100)\n+\n+fig, ax = plt.subplots(constrained_layout=True)\n+ax.plot(dates.values, data)  # Convert to numpy array\n+plt.savefig(\"test_output.png\")\n+print(f\"Matplotlib version: {matplotlib.__version__}\")\n+print(\"Plot saved as test_output.png\")\n\\ No newline at end of file\ndiff --git a/reproduce_pr_issue.py b/reproduce_pr_issue.py\nnew file mode 100644\nindex 0000000000..7b1433d7d3\n--- /dev/null\n+++ b/reproduce_pr_issue.py\n@@ -0,0 +1,60 @@\n+import matplotlib\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import pandas as pd\n+import matplotlib.dates as mdates\n+\n+np.random.seed(1)\n+\n+dates = pd.date_range(\"2020-01-01 00:00:00\", end=\"2020-01-01 00:10:00\", periods=100)\n+data = np.random.rand(100)\n+\n+# Test without usetex\n+print(\"Testing without usetex:\")\n+matplotlib.rcParams[\"text.usetex\"] = False\n+fig, ax = plt.subplots(constrained_layout=True)\n+ax.plot(dates.values, data)\n+\n+# Get the tick labels\n+labels_no_tex = [label.get_text() for label in ax.get_xticklabels()]\n+print(\"Labels without usetex:\", labels_no_tex)\n+\n+# Test with usetex\n+print(\"\\nTesting with usetex:\")\n+matplotlib.rcParams[\"text.usetex\"] = True\n+fig2, ax2 = plt.subplots(constrained_layout=True)\n+ax2.plot(dates.values, data)\n+\n+# Get the tick labels\n+labels_with_tex = [label.get_text() for label in ax2.get_xticklabels()]\n+print(\"Labels with usetex:\", labels_with_tex)\n+\n+# Test the formatters directly\n+print(\"\\nTesting formatters directly:\")\n+d1 = dates[0].to_pydatetime()\n+d2 = dates[-1].to_pydatetime()\n+\n+locator = mdates.AutoDateLocator()\n+locator.create_dummy_axis()\n+locator.axis.set_view_interval(mdates.date2num(d1), mdates.date2num(d2))\n+\n+# Without usetex\n+formatter_no_tex = mdates.AutoDateFormatter(locator, usetex=False)\n+locations = locator()\n+formatted_no_tex = [formatter_no_tex(loc) for loc in locations]\n+print(\"Formatted without usetex:\", formatted_no_tex)\n+\n+# With usetex\n+formatter_with_tex = mdates.AutoDateFormatter(locator, usetex=True)\n+formatted_with_tex = [formatter_with_tex(loc) for loc in locations]\n+print(\"Formatted with usetex:\", formatted_with_tex)\n+\n+# Test ConciseDateFormatter too\n+print(\"\\nTesting ConciseDateFormatter:\")\n+concise_formatter_no_tex = mdates.ConciseDateFormatter(locator, usetex=False)\n+concise_formatted_no_tex = concise_formatter_no_tex.format_ticks(locations)\n+print(\"Concise formatted without usetex:\", concise_formatted_no_tex)\n+\n+concise_formatter_with_tex = mdates.ConciseDateFormatter(locator, usetex=True)\n+concise_formatted_with_tex = concise_formatter_with_tex.format_ticks(locations)\n+print(\"Concise formatted with usetex:\", concise_formatted_with_tex)\n\\ No newline at end of file\ndiff --git a/test_datetime_simple.py b/test_datetime_simple.py\nnew file mode 100644\nindex 0000000000..5e3d14d80e\n--- /dev/null\n+++ b/test_datetime_simple.py\n@@ -0,0 +1,21 @@\n+import matplotlib\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import pandas as pd\n+\n+np.random.seed(1)\n+\n+dates = pd.date_range(\"2020-01-01 00:00:00\", end=\"2020-01-01 00:10:00\", periods=100)\n+data = np.random.rand(100)\n+\n+# Test without usetex first\n+fig, ax = plt.subplots(constrained_layout=True)\n+ax.plot(dates.values, data)\n+plt.savefig(\"test_output_no_tex.png\")\n+print(f\"Matplotlib version: {matplotlib.__version__}\")\n+print(\"Plot saved as test_output_no_tex.png\")\n+\n+# Show the tick labels\n+print(\"X-axis tick labels:\")\n+for i, label in enumerate(ax.get_xticklabels()):\n+    print(f\"  {i}: {label.get_text()}\")\n\\ No newline at end of file\ndiff --git a/test_fix_wrap_in_tex.py b/test_fix_wrap_in_tex.py\nnew file mode 100644\nindex 0000000000..bd24482f2b\n--- /dev/null\n+++ b/test_fix_wrap_in_tex.py\n@@ -0,0 +1,54 @@\n+import re\n+\n+def _wrap_in_tex_current(text):\n+    p = r'([a-zA-Z]+)'\n+    ret_text = re.sub(p, r'}$\\1$\\\\mathdefault{', text)\n+\n+    # Braces ensure dashes are not spaced like binary operators.\n+    ret_text = '$\\\\mathdefault{'+ret_text.replace('-', '{-}')+'}$'\n+    ret_text = ret_text.replace('$\\\\mathdefault{}$', '')\n+    return ret_text\n+\n+def _wrap_in_tex_fixed(text):\n+    p = r'([a-zA-Z]+)'\n+    ret_text = re.sub(p, r'}$\\1$\\\\mathdefault{', text)\n+\n+    # Braces ensure dashes are not spaced like binary operators.\n+    ret_text = '$\\\\mathdefault{'+ret_text.replace('-', '{-}')+'}$'\n+    ret_text = ret_text.replace('$\\\\mathdefault{}$', '')\n+    \n+    # Fix spacing in math mode by replacing spaces with explicit LaTeX spacing\n+    # Replace spaces inside \\mathdefault{...} with \\  (explicit space)\n+    def replace_spaces_in_mathdefault(match):\n+        content = match.group(1)\n+        # Replace spaces with explicit LaTeX spaces\n+        content_with_spaces = content.replace(' ', r'\\ ')\n+        return f'$\\\\mathdefault{{{content_with_spaces}}}$'\n+    \n+    ret_text = re.sub(r'\\$\\\\mathdefault\\{([^}]*)\\}\\$', replace_spaces_in_mathdefault, ret_text)\n+    \n+    return ret_text\n+\n+# Test cases\n+test_cases = [\n+    \"01 00:00\",\n+    \"01 00:05\", \n+    \"01 00:10\",\n+    \"Jan 01 1990\",\n+    \"Feb 15 2020\",\n+    \"12:30\",\n+    \"2020-01-01\",\n+    \"Jan\",\n+    \"Feb\"\n+]\n+\n+print(\"Comparing current vs fixed implementation:\")\n+print(\"=\" * 60)\n+for case in test_cases:\n+    current = _wrap_in_tex_current(case)\n+    fixed = _wrap_in_tex_fixed(case)\n+    print(f\"Input: '{case}'\")\n+    print(f\"Current:  '{current}'\")\n+    print(f\"Fixed:    '{fixed}'\")\n+    print(f\"Changed:  {current != fixed}\")\n+    print()\n\\ No newline at end of file\ndiff --git a/test_latex_spacing.py b/test_latex_spacing.py\nnew file mode 100644\nindex 0000000000..a741e05112\n--- /dev/null\n+++ b/test_latex_spacing.py\n@@ -0,0 +1,59 @@\n+import matplotlib\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+# Test different LaTeX spacing approaches\n+test_strings = [\n+    \"01 00:00\",  # Normal space\n+    r\"$\\mathdefault{01 00:00}$\",  # Current approach\n+    r\"$\\mathdefault{01\\ 00:00}$\",  # LaTeX space\n+    r\"$\\mathdefault{01\\,00:00}$\",  # LaTeX thin space\n+    r\"$\\mathdefault{01\\;00:00}$\",  # LaTeX medium space\n+    r\"$\\mathdefault{01\\quad 00:00}$\",  # LaTeX quad space\n+]\n+\n+# Create a simple plot to test text rendering\n+fig, ax = plt.subplots(figsize=(10, 6))\n+\n+# Test without usetex first\n+matplotlib.rcParams[\"text.usetex\"] = False\n+for i, text in enumerate(test_strings[:1]):  # Only test the first one without usetex\n+    ax.text(0.1, 0.9 - i*0.1, f\"No TeX: {text}\", transform=ax.transAxes)\n+\n+# Test with usetex\n+matplotlib.rcParams[\"text.usetex\"] = True\n+for i, text in enumerate(test_strings[1:], 1):  # Test the LaTeX versions\n+    try:\n+        ax.text(0.1, 0.9 - i*0.1, f\"TeX {i}: {text}\", transform=ax.transAxes)\n+    except Exception as e:\n+        ax.text(0.1, 0.9 - i*0.1, f\"TeX {i}: ERROR - {str(e)[:50]}\", transform=ax.transAxes)\n+\n+ax.set_xlim(0, 1)\n+ax.set_ylim(0, 1)\n+ax.set_title(\"LaTeX Spacing Test\")\n+\n+plt.savefig(\"latex_spacing_test.png\", dpi=150, bbox_inches='tight')\n+print(\"Saved latex_spacing_test.png\")\n+\n+# Also test the actual datetime formatting\n+import pandas as pd\n+import matplotlib.dates as mdates\n+\n+dates = pd.date_range(\"2020-01-01 00:00:00\", end=\"2020-01-01 00:10:00\", periods=5)\n+data = np.random.rand(5)\n+\n+fig2, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n+\n+# Without usetex\n+matplotlib.rcParams[\"text.usetex\"] = False\n+ax1.plot(dates.values, data)\n+ax1.set_title(\"Without usetex\")\n+\n+# With usetex\n+matplotlib.rcParams[\"text.usetex\"] = True\n+ax2.plot(dates.values, data)\n+ax2.set_title(\"With usetex\")\n+\n+plt.tight_layout()\n+plt.savefig(\"datetime_comparison.png\", dpi=150, bbox_inches='tight')\n+print(\"Saved datetime_comparison.png\")\n\\ No newline at end of file\ndiff --git a/test_output_no_tex.png b/test_output_no_tex.png\nnew file mode 100644\nindex 0000000000..d8543c820b\nBinary files /dev/null and b/test_output_no_tex.png differ\ndiff --git a/test_wrap_in_tex.py b/test_wrap_in_tex.py\nnew file mode 100644\nindex 0000000000..e228d8a586\n--- /dev/null\n+++ b/test_wrap_in_tex.py\n@@ -0,0 +1,31 @@\n+import re\n+\n+def _wrap_in_tex_current(text):\n+    p = r'([a-zA-Z]+)'\n+    ret_text = re.sub(p, r'}$\\1$\\\\mathdefault{', text)\n+\n+    # Braces ensure dashes are not spaced like binary operators.\n+    ret_text = '$\\\\mathdefault{'+ret_text.replace('-', '{-}')+'}$'\n+    ret_text = ret_text.replace('$\\\\mathdefault{}$', '')\n+    return ret_text\n+\n+# Test with datetime strings\n+test_strings = [\n+    \"01 00:00\",\n+    \"01 00:05\", \n+    \"01 00:10\",\n+    \"Jan\",\n+    \"Feb\",\n+    \"2020-01-01\",\n+    \"12:30\",\n+    \"00:00\",\n+    \"Jan 01\",\n+    \"Feb 15\",\n+    \"Mon 12:30\",\n+    \"Tue 14:45\"\n+]\n+\n+print(\"Current _wrap_in_tex behavior:\")\n+for s in test_strings:\n+    result = _wrap_in_tex_current(s)\n+    print(f\"'{s}' -> '{result}'\")\n\\ No newline at end of file\n"}