{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-15973", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 09785e8586..ec9fa40c1d 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -20,6 +20,25 @@ from django.utils import timezone\n logger = logging.getLogger(\"django.db.backends.schema\")\n \n \n+def _resolve_through_model(field, model):\n+    \"\"\"\n+    Resolve the through model for a ManyToManyField.\n+    \n+    If field.remote_field.through is a string, resolve it to the actual model class\n+    using the model's apps registry. Otherwise, return it as-is.\n+    \"\"\"\n+    through = field.remote_field.through\n+    if isinstance(through, str):\n+        # Resolve string reference to actual model class\n+        try:\n+            return model._meta.apps.get_model(through)\n+        except (LookupError, ValueError):\n+            # If we can't resolve the model, return the string\n+            # This maintains backward compatibility and lets other code handle the error\n+            return through\n+    return through\n+\n+\n def _is_relevant_relation(relation, altered_field):\n     \"\"\"\n     When altering the given field, must constraints on its model from the given\n@@ -450,15 +469,17 @@ class BaseDatabaseSchemaEditor:\n \n         # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.create_model(field.remote_field.through)\n+            through_model = _resolve_through_model(field, model)\n+            if hasattr(through_model, '_meta') and through_model._meta.auto_created:\n+                self.create_model(through_model)\n \n     def delete_model(self, model):\n         \"\"\"Delete a model from the database.\"\"\"\n         # Handle auto-created intermediary models\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.delete_model(field.remote_field.through)\n+            through_model = _resolve_through_model(field, model)\n+            if hasattr(through_model, '_meta') and through_model._meta.auto_created:\n+                self.delete_model(through_model)\n \n         # Delete the table\n         self.execute(\n@@ -630,8 +651,10 @@ class BaseDatabaseSchemaEditor:\n         involve adding a table instead (for M2M fields).\n         \"\"\"\n         # Special-case implicit M2M tables\n-        if field.many_to_many and field.remote_field.through._meta.auto_created:\n-            return self.create_model(field.remote_field.through)\n+        if field.many_to_many:\n+            through_model = _resolve_through_model(field, model)\n+            if hasattr(through_model, '_meta') and through_model._meta.auto_created:\n+                return self.create_model(through_model)\n         # Get the column's definition\n         definition, params = self.column_sql(model, field, include_default=True)\n         # It might not actually have a column behind it\n@@ -704,8 +727,10 @@ class BaseDatabaseSchemaEditor:\n         but for M2Ms may involve deleting a table.\n         \"\"\"\n         # Special-case implicit M2M tables\n-        if field.many_to_many and field.remote_field.through._meta.auto_created:\n-            return self.delete_model(field.remote_field.through)\n+        if field.many_to_many:\n+            through_model = _resolve_through_model(field, model)\n+            if hasattr(through_model, '_meta') and through_model._meta.auto_created:\n+                return self.delete_model(through_model)\n         # It might not actually have a column behind it\n         if field.db_parameters(connection=self.connection)[\"type\"] is None:\n             return\n@@ -759,23 +784,31 @@ class BaseDatabaseSchemaEditor:\n             and (\n                 old_field.remote_field.through\n                 and new_field.remote_field.through\n-                and old_field.remote_field.through._meta.auto_created\n-                and new_field.remote_field.through._meta.auto_created\n             )\n         ):\n-            return self._alter_many_to_many(model, old_field, new_field, strict)\n+            old_through_model = _resolve_through_model(old_field, model)\n+            new_through_model = _resolve_through_model(new_field, model)\n+            if (\n+                hasattr(old_through_model, '_meta') and old_through_model._meta.auto_created\n+                and hasattr(new_through_model, '_meta') and new_through_model._meta.auto_created\n+            ):\n+                return self._alter_many_to_many(model, old_field, new_field, strict)\n         elif (\n             old_type is None\n             and new_type is None\n             and (\n                 old_field.remote_field.through\n                 and new_field.remote_field.through\n-                and not old_field.remote_field.through._meta.auto_created\n-                and not new_field.remote_field.through._meta.auto_created\n             )\n         ):\n-            # Both sides have through models; this is a no-op.\n-            return\n+            old_through_model = _resolve_through_model(old_field, model)\n+            new_through_model = _resolve_through_model(new_field, model)\n+            if (\n+                hasattr(old_through_model, '_meta') and not old_through_model._meta.auto_created\n+                and hasattr(new_through_model, '_meta') and not new_through_model._meta.auto_created\n+            ):\n+                # Both sides have through models; this is a no-op.\n+                return\n         elif old_type is None or new_type is None:\n             raise ValueError(\n                 \"Cannot alter field %s into %s - they are not compatible types \"\n@@ -1246,35 +1279,39 @@ class BaseDatabaseSchemaEditor:\n \n     def _alter_many_to_many(self, model, old_field, new_field, strict):\n         \"\"\"Alter M2Ms to repoint their to= endpoints.\"\"\"\n+        old_through_model = _resolve_through_model(old_field, model)\n+        new_through_model = _resolve_through_model(new_field, model)\n+        \n         # Rename the through table\n         if (\n-            old_field.remote_field.through._meta.db_table\n-            != new_field.remote_field.through._meta.db_table\n+            hasattr(old_through_model, '_meta') and hasattr(new_through_model, '_meta')\n+            and old_through_model._meta.db_table != new_through_model._meta.db_table\n         ):\n             self.alter_db_table(\n-                old_field.remote_field.through,\n-                old_field.remote_field.through._meta.db_table,\n-                new_field.remote_field.through._meta.db_table,\n+                old_through_model,\n+                old_through_model._meta.db_table,\n+                new_through_model._meta.db_table,\n             )\n         # Repoint the FK to the other side\n-        self.alter_field(\n-            new_field.remote_field.through,\n-            # The field that points to the target model is needed, so we can\n-            # tell alter_field to change it - this is m2m_reverse_field_name()\n-            # (as opposed to m2m_field_name(), which points to our model).\n-            old_field.remote_field.through._meta.get_field(\n-                old_field.m2m_reverse_field_name()\n-            ),\n-            new_field.remote_field.through._meta.get_field(\n-                new_field.m2m_reverse_field_name()\n-            ),\n-        )\n-        self.alter_field(\n-            new_field.remote_field.through,\n-            # for self-referential models we need to alter field from the other end too\n-            old_field.remote_field.through._meta.get_field(old_field.m2m_field_name()),\n-            new_field.remote_field.through._meta.get_field(new_field.m2m_field_name()),\n-        )\n+        if hasattr(new_through_model, '_meta'):\n+            self.alter_field(\n+                new_through_model,\n+                # The field that points to the target model is needed, so we can\n+                # tell alter_field to change it - this is m2m_reverse_field_name()\n+                # (as opposed to m2m_field_name(), which points to our model).\n+                old_through_model._meta.get_field(\n+                    old_field.m2m_reverse_field_name()\n+                ),\n+                new_through_model._meta.get_field(\n+                    new_field.m2m_reverse_field_name()\n+                ),\n+            )\n+            self.alter_field(\n+                new_through_model,\n+                # for self-referential models we need to alter field from the other end too\n+                old_through_model._meta.get_field(old_field.m2m_field_name()),\n+                new_through_model._meta.get_field(new_field.m2m_field_name()),\n+            )\n \n     def _create_index_name(self, table_name, column_names, suffix=\"\"):\n         \"\"\"\n"}