{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "sphinx-doc__sphinx-8638", "model_patch": "diff --git a/setup.py b/setup.py\nindex a0c8ac102..2ef89ef1a 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -15,22 +15,22 @@ if sys.version_info < (3, 6):\n     sys.exit(1)\n \n install_requires = [\n-    'sphinxcontrib-applehelp',\n-    'sphinxcontrib-devhelp',\n+    'sphinxcontrib-applehelp<=1.0.7',\n+    'sphinxcontrib-devhelp<=1.0.5',\n     'sphinxcontrib-jsmath',\n-    'sphinxcontrib-htmlhelp',\n-    'sphinxcontrib-serializinghtml',\n-    'sphinxcontrib-qthelp',\n-    'Jinja2>=2.3',\n+    'sphinxcontrib-htmlhelp<=2.0.4',\n+    'sphinxcontrib-serializinghtml<=1.1.9',\n+    'sphinxcontrib-qthelp<=1.0.6',\n+    'Jinja2<3.0',\n     'Pygments>=2.0',\n     'docutils>=0.14',\n     'snowballstemmer>=1.1',\n     'babel>=1.3',\n-    'alabaster>=0.7,<0.8',\n+    'alabaster>=0.7,<0.7.12',\n     'imagesize',\n     'requests>=2.5.0',\n     'setuptools',\n-    'packaging',\n+    'packaging', 'markupsafe<=2.0.1',\n ]\n \n extras_require = {\ndiff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 000e2e8d3..e75c30da5 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -1128,6 +1128,7 @@ class PythonDomain(Domain):\n         \"\"\"Find a Python object for \"name\", perhaps using the given module\n         and/or classname.  Returns a list of (name, object entry) tuples.\n         \"\"\"\n+\n         # skip parens\n         if name[-2:] == '()':\n             name = name[:-2]\n@@ -1157,25 +1158,71 @@ class PythonDomain(Domain):\n                     else:\n                         # \"fuzzy\" searching mode\n                         searchname = '.' + name\n-                        matches = [(oname, self.objects[oname]) for oname in self.objects\n-                                   if oname.endswith(searchname) and\n-                                   self.objects[oname].objtype in objtypes]\n+                        candidates = [(oname, self.objects[oname]) for oname in self.objects\n+                                     if oname.endswith(searchname) and\n+                                     self.objects[oname].objtype in objtypes]\n+                        \n+                        # Prioritize matches based on context\n+                        if candidates:\n+                            # If we have a current module and/or class context, prefer matches within that context\n+                            context_matches = []\n+                            module_matches = []\n+                            \n+                            for oname, obj in candidates:\n+                                # Check if this match is within the current class context\n+                                if modname and classname:\n+                                    expected_prefix = modname + '.' + classname + '.'\n+                                    if oname.startswith(expected_prefix):\n+                                        context_matches.append((oname, obj))\n+                                        continue\n+                                \n+                                # Check if this match is within the current module context\n+                                if modname:\n+                                    expected_prefix = modname + '.'\n+                                    if oname.startswith(expected_prefix):\n+                                        module_matches.append((oname, obj))\n+                                        continue\n+                            \n+                            # Use the most specific matches available\n+                            if context_matches:\n+                                matches = context_matches\n+                            elif module_matches:\n+                                matches = module_matches\n+                            else:\n+                                # Only fall back to all candidates if no context-specific matches found\n+                                matches = candidates\n         else:\n             # NOTE: searching for exact match, object type is not considered\n-            if name in self.objects:\n-                newname = name\n-            elif type == 'mod':\n-                # only exact matches allowed for modules\n-                return []\n+            # Try more specific matches first to avoid incorrect cross-references\n+            if modname and classname and \\\n+                    modname + '.' + classname + '.' + name in self.objects:\n+                newname = modname + '.' + classname + '.' + name\n             elif classname and classname + '.' + name in self.objects:\n                 newname = classname + '.' + name\n             elif modname and modname + '.' + name in self.objects:\n                 newname = modname + '.' + name\n-            elif modname and classname and \\\n-                    modname + '.' + classname + '.' + name in self.objects:\n-                newname = modname + '.' + classname + '.' + name\n+            elif type == 'mod':\n+                # only exact matches allowed for modules\n+                return []\n+            elif name in self.objects:\n+                newname = name\n+            else:\n+                # If we have a module context but no class context, and we're looking for an attribute,\n+                # search for any attribute with that name within the module\n+                if modname and type == 'attr':\n+                    module_prefix = modname + '.'\n+                    candidates = [oname for oname in self.objects.keys() \n+                                 if oname.startswith(module_prefix) and oname.endswith('.' + name)\n+                                 and self.objects[oname].objtype == 'attribute']\n+                    if candidates:\n+                        # If there's only one candidate, use it\n+                        if len(candidates) == 1:\n+                            newname = candidates[0]\n+                        # If there are multiple candidates, we could potentially pick the \"best\" one\n+                        # but for now, let's not match to avoid ambiguity\n         if newname is not None:\n             matches.append((newname, self.objects[newname]))\n+\n         return matches\n \n     def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,\ndiff --git a/tox.ini b/tox.ini\nindex bdf4c2ad3..b12166264 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -26,7 +26,7 @@ setenv =\n     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils,ignore::DeprecationWarning:pip._vendor.packaging.version\n     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes\n commands=\n-    python -X dev -m pytest --durations 25 {posargs}\n+    python -X dev -m pytest -rA --durations 25 {posargs}\n \n [testenv:flake8]\n basepython = python3\n"}