{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "sympy__sympy-13551", "model_patch": "diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py\nindex 66aafde2d6..ac891a00b4 100644\n--- a/sympy/concrete/products.py\n+++ b/sympy/concrete/products.py\n@@ -282,10 +282,31 @@ def _eval_product(self, term, limits):\n                 # There is expression, which couldn't change by\n                 # as_numer_denom(). E.g. n**(2/3) + 1 --> (n**(2/3) + 1, 1).\n                 # We have to catch this case.\n-\n-                p = sum([self._eval_product(i, (k, a, n)) for i in p.as_coeff_Add()])\n+                \n+                # However, we cannot compute Product(a + b) as Product(a) + Product(b)\n+                # This is mathematically incorrect. We should only do this if the\n+                # addition can be properly factored or simplified.\n+                \n+                # Check if this is a simple case where all terms are constants\n+                # or can be factored out\n+                terms = p.as_coeff_Add()\n+                can_factor = True\n+                for term in terms:\n+                    if term.has(k):\n+                        can_factor = False\n+                        break\n+                \n+                if can_factor:\n+                    # All terms are constants, so Product(a + b) = (a + b)^(number of terms)\n+                    p = p**(n - a + 1)\n+                else:\n+                    # Cannot safely compute this, return None\n+                    return None\n             else:\n                 p = self._eval_product(p, (k, a, n))\n+            \n+            if p is None:\n+                return None\n             return p / q\n \n         elif term.is_Mul:\n"}