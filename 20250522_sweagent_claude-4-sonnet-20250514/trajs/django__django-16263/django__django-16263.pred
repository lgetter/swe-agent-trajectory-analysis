{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-16263", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 9735ce10c8..f80a14cb1d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -450,17 +450,44 @@ class Query(BaseExpression):\n         #\n         # Existing annotations would cause incorrect results as get_aggregation()\n         # must produce just one result and thus must not use GROUP BY. But we\n-        # aren't smart enough to remove the existing annotations from the\n-        # query, so those would force us to use GROUP BY.\n+        # can be smart about removing unused annotations from count queries.\n         #\n         # If the query has limit or distinct, or uses set operations, then\n         # those operations must be done in a subquery so that the query\n         # aggregates on the limit and/or distinct results instead of applying\n         # the distinct and limit after the aggregation.\n+        \n+        # For count queries, check if existing annotations are actually referenced\n+        # Only apply this optimization if all existing annotations are simple aggregates\n+        # (not subqueries or complex expressions that might affect grouping)\n+        is_count_query = (\n+            len(added_aggregate_names) == 1 and \n+            \"__count\" in added_aggregate_names and\n+            isinstance(self.annotations.get(\"__count\"), Count) and\n+            all(\n+                hasattr(annotation, 'empty_result_set_value') and \n+                getattr(annotation, 'contains_aggregate', True) and\n+                not getattr(annotation, 'contains_subquery', False)\n+                for annotation in existing_annotations\n+            )\n+        )\n+        \n+        if is_count_query:\n+            # For count queries, only consider annotations that are actually referenced\n+            referenced_annotations = self._get_referenced_annotations(\n+                set(alias for alias in self.annotations.keys() if alias not in added_aggregate_names)\n+            )\n+            relevant_existing_annotations = [\n+                annotation for alias, annotation in self.annotations.items()\n+                if alias not in added_aggregate_names and alias in referenced_annotations\n+            ]\n+        else:\n+            relevant_existing_annotations = existing_annotations\n+        \n         if (\n             isinstance(self.group_by, tuple)\n             or self.is_sliced\n-            or existing_annotations\n+            or relevant_existing_annotations\n             or self.distinct\n             or self.combinator\n         ):\n@@ -484,7 +511,7 @@ class Query(BaseExpression):\n                 # used.\n                 has_existing_aggregate_annotations = any(\n                     annotation\n-                    for annotation in existing_annotations\n+                    for annotation in relevant_existing_annotations\n                     if getattr(annotation, \"contains_aggregate\", True)\n                 )\n                 if inner_query.default_cols and has_existing_aggregate_annotations:\n@@ -545,12 +572,102 @@ class Query(BaseExpression):\n \n         return dict(zip(outer_query.annotation_select, result))\n \n+    def _get_referenced_annotations(self, annotations_to_check=None):\n+        \"\"\"\n+        Return a set of annotation aliases that are referenced in the query's\n+        WHERE clause, ORDER BY clause, or by other annotations.\n+        \"\"\"\n+        if annotations_to_check is None:\n+            annotations_to_check = set(self.annotations.keys())\n+        \n+        referenced = set()\n+        \n+        # Check WHERE clause - look for direct alias references\n+        where_aliases = set(self._gen_col_aliases([self.where]))\n+        referenced.update(where_aliases & annotations_to_check)\n+        \n+        # Also check if WHERE clause contains expressions that match annotations\n+        # This handles cases like author_count__gt=1 which creates HAVING clauses\n+        def find_matching_annotations(expr, annotations_dict):\n+            \"\"\"Find annotation aliases whose expressions match the given expression.\"\"\"\n+            matches = set()\n+            for alias, annotation in annotations_dict.items():\n+                if alias in annotations_to_check and str(expr) == str(annotation):\n+                    matches.add(alias)\n+            return matches\n+        \n+        def check_expression_tree(expr):\n+            \"\"\"Recursively check an expression tree for annotation matches.\"\"\"\n+            matches = set()\n+            if hasattr(expr, 'children'):\n+                for child in expr.children:\n+                    matches.update(check_expression_tree(child))\n+            elif hasattr(expr, 'lhs'):\n+                # This is likely a lookup like GreaterThan\n+                matches.update(find_matching_annotations(expr.lhs, self.annotations))\n+                if hasattr(expr, 'rhs'):\n+                    matches.update(check_expression_tree(expr.rhs))\n+            elif hasattr(expr, 'source_expressions'):\n+                for source_expr in expr.source_expressions:\n+                    matches.update(check_expression_tree(source_expr))\n+            else:\n+                matches.update(find_matching_annotations(expr, self.annotations))\n+            return matches\n+        \n+        referenced.update(check_expression_tree(self.where))\n+        \n+        # Check ORDER BY clause\n+        order_by_aliases = set(self._gen_col_aliases(self.order_by))\n+        referenced.update(order_by_aliases & annotations_to_check)\n+        \n+        # Check if annotations reference each other\n+        # We need to do this iteratively until no new references are found\n+        changed = True\n+        while changed:\n+            changed = False\n+            for alias, annotation in self.annotations.items():\n+                if alias in referenced:\n+                    continue\n+                # Check if this annotation references any already referenced annotations\n+                annotation_aliases = set(self._gen_col_aliases([annotation]))\n+                if annotation_aliases & referenced:\n+                    referenced.add(alias)\n+                    changed = True\n+        \n+        return referenced\n+\n     def get_count(self, using):\n         \"\"\"\n         Perform a COUNT() query using the current filter constraints.\n         \"\"\"\n         obj = self.clone()\n-        obj.add_annotation(Count(\"*\"), alias=\"__count\", is_summary=True)\n+        \n+        # For count queries, if there are unused annotations that introduce JOINs,\n+        # we need to count distinct primary keys to avoid counting duplicate rows\n+        referenced_annotations = obj._get_referenced_annotations()\n+        unused_annotations = set(obj.annotations.keys()) - referenced_annotations\n+        \n+        # Check if any unused annotations introduce JOINs\n+        has_unused_joins = False\n+        for alias in unused_annotations:\n+            annotation = obj.annotations[alias]\n+            annotation_aliases = set(obj._gen_col_aliases([annotation]))\n+            if any(\n+                isinstance(obj.alias_map.get(col_alias), Join)\n+                for col_alias in annotation_aliases\n+                if col_alias in obj.alias_map\n+            ):\n+                has_unused_joins = True\n+                break\n+        \n+        if has_unused_joins and not referenced_annotations:\n+            # If we have unused annotations with JOINs but no referenced annotations,\n+            # we can use COUNT(DISTINCT pk) to get the correct count\n+            pk_col = obj.model._meta.pk.get_col(obj.get_initial_alias())\n+            obj.add_annotation(Count(pk_col, distinct=True), alias=\"__count\", is_summary=True)\n+        else:\n+            obj.add_annotation(Count(\"*\"), alias=\"__count\", is_summary=True)\n+        \n         return obj.get_aggregation(using, [\"__count\"])[\"__count\"]\n \n     def has_filters(self):\n"}