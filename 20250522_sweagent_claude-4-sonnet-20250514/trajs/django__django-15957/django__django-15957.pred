{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-15957", "model_patch": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex b192df4fbf..8f8a7e1c87 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -145,7 +145,27 @@ class ForwardManyToOneDescriptor:\n             }\n         else:\n             query = {\"%s__in\" % self.field.related_query_name(): instances}\n-        queryset = queryset.filter(**query)\n+        \n+        # Handle sliced querysets by evaluating first, then filtering in Python\n+        if queryset.query.is_sliced:\n+            # Evaluate the sliced queryset to get the actual objects\n+            sliced_objects = list(queryset)\n+            \n+            # Create a new queryset from the sliced objects\n+            if sliced_objects:\n+                # Get the IDs of the sliced objects\n+                sliced_ids = [obj.pk for obj in sliced_objects]\n+                \n+                # Create a new queryset that includes only these objects\n+                base_queryset = queryset.model.objects.filter(pk__in=sliced_ids)\n+                \n+                # Apply the filter to this new queryset\n+                queryset = base_queryset.filter(**query)\n+            else:\n+                # If the slice resulted in no objects, return an empty queryset\n+                queryset = queryset.model.objects.none()\n+        else:\n+            queryset = queryset.filter(**query)\n \n         # Since we're going to assign directly in the cache,\n         # we must manage the reverse relation cache manually.\n@@ -404,7 +424,27 @@ class ReverseOneToOneDescriptor:\n         instance_attr = self.related.field.get_foreign_related_value\n         instances_dict = {instance_attr(inst): inst for inst in instances}\n         query = {\"%s__in\" % self.related.field.name: instances}\n-        queryset = queryset.filter(**query)\n+        \n+        # Handle sliced querysets by evaluating first, then filtering in Python\n+        if queryset.query.is_sliced:\n+            # Evaluate the sliced queryset to get the actual objects\n+            sliced_objects = list(queryset)\n+            \n+            # Create a new queryset from the sliced objects\n+            if sliced_objects:\n+                # Get the IDs of the sliced objects\n+                sliced_ids = [obj.pk for obj in sliced_objects]\n+                \n+                # Create a new queryset that includes only these objects\n+                base_queryset = queryset.model.objects.filter(pk__in=sliced_ids)\n+                \n+                # Apply the filter to this new queryset\n+                queryset = base_queryset.filter(**query)\n+            else:\n+                # If the slice resulted in no objects, return an empty queryset\n+                queryset = queryset.model.objects.none()\n+        else:\n+            queryset = queryset.filter(**query)\n \n         # Since we're going to assign directly in the cache,\n         # we must manage the reverse relation cache manually.\n@@ -719,7 +759,27 @@ def create_reverse_many_to_one_manager(superclass, rel):\n             instance_attr = self.field.get_foreign_related_value\n             instances_dict = {instance_attr(inst): inst for inst in instances}\n             query = {\"%s__in\" % self.field.name: instances}\n-            queryset = queryset.filter(**query)\n+            \n+            # Handle sliced querysets by evaluating first, then filtering in Python\n+            if queryset.query.is_sliced:\n+                # Evaluate the sliced queryset to get the actual objects\n+                sliced_objects = list(queryset)\n+                \n+                # Create a new queryset from the sliced objects\n+                if sliced_objects:\n+                    # Get the IDs of the sliced objects\n+                    sliced_ids = [obj.pk for obj in sliced_objects]\n+                    \n+                    # Create a new queryset that includes only these objects\n+                    base_queryset = queryset.model.objects.filter(pk__in=sliced_ids)\n+                    \n+                    # Apply the filter to this new queryset\n+                    queryset = base_queryset.filter(**query)\n+                else:\n+                    # If the slice resulted in no objects, return an empty queryset\n+                    queryset = queryset.model.objects.none()\n+            else:\n+                queryset = queryset.filter(**query)\n \n             # Since we just bypassed this class' get_queryset(), we must manage\n             # the reverse relation manually.\n@@ -1052,8 +1112,7 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n             queryset = queryset.using(queryset._db or self._db)\n \n             query = {\"%s__in\" % self.query_field_name: instances}\n-            queryset = queryset._next_is_sticky().filter(**query)\n-\n+            \n             # M2M: need to annotate the query in order to get the primary model\n             # that the secondary model was actually related to. We know that\n             # there will already be a join on the join table, so we can just add\n@@ -1065,14 +1124,35 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n             join_table = fk.model._meta.db_table\n             connection = connections[queryset.db]\n             qn = connection.ops.quote_name\n-            queryset = queryset.extra(\n-                select={\n-                    \"_prefetch_related_val_%s\"\n-                    % f.attname: \"%s.%s\"\n-                    % (qn(join_table), qn(f.column))\n-                    for f in fk.local_related_fields\n-                }\n-            )\n+            extra_select = {\n+                \"_prefetch_related_val_%s\"\n+                % f.attname: \"%s.%s\"\n+                % (qn(join_table), qn(f.column))\n+                for f in fk.local_related_fields\n+            }\n+            \n+            # Handle sliced querysets by evaluating first, then filtering in Python\n+            if queryset.query.is_sliced:\n+                # Evaluate the sliced queryset to get the actual objects\n+                sliced_objects = list(queryset)\n+                \n+                # Create a new queryset from the sliced objects\n+                if sliced_objects:\n+                    # Get the IDs of the sliced objects\n+                    sliced_ids = [obj.pk for obj in sliced_objects]\n+                    \n+                    # Create a new queryset that includes only these objects\n+                    base_queryset = queryset.model.objects.filter(pk__in=sliced_ids)\n+                    \n+                    # Apply the filter and extra to this new queryset\n+                    filtered_queryset = base_queryset._next_is_sticky().filter(**query)\n+                    queryset = filtered_queryset.extra(select=extra_select)\n+                else:\n+                    # If the slice resulted in no objects, return an empty queryset\n+                    queryset = queryset.model.objects.none()\n+            else:\n+                queryset = queryset._next_is_sticky().filter(**query)\n+                queryset = queryset.extra(select=extra_select)\n             return (\n                 queryset,\n                 lambda result: tuple(\n"}