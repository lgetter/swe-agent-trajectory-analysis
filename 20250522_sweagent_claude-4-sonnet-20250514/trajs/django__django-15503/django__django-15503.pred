{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-15503", "model_patch": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9d..2e93e0c9e0 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -139,6 +139,18 @@ def compile_json_path(key_transforms, include_root=True):\n     return \"\".join(path)\n \n \n+def compile_json_path_for_has_key(key_transforms, include_root=True):\n+    \"\"\"\n+    Compile a JSON path for has_key lookups, treating all keys as object keys.\n+    This is different from compile_json_path which treats numeric strings as array indices.\n+    \"\"\"\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        path.append(\".\")\n+        path.append(json.dumps(key_transform))\n+    return \"\".join(path)\n+\n+\n class DataContains(PostgresOperatorLookup):\n     lookup_name = \"contains\"\n     postgres_operator = \"@>\"\n@@ -178,6 +190,8 @@ class HasKeyLookup(PostgresOperatorLookup):\n             lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(\n                 compiler, connection\n             )\n+            # Use the original compile_json_path for the path to the object,\n+            # as it may contain array indices\n             lhs_json_path = compile_json_path(lhs_key_transforms)\n         else:\n             lhs, lhs_params = self.process_lhs(compiler, connection)\n@@ -191,15 +205,21 @@ class HasKeyLookup(PostgresOperatorLookup):\n         for key in rhs:\n             if isinstance(key, KeyTransform):\n                 *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n+                # For KeyTransform, we need to split the path:\n+                # - All but the last element use normal path compilation (may include array indices)\n+                # - The last element is always an object key for has_key lookups\n+                if len(rhs_key_transforms) > 1:\n+                    path_to_object = compile_json_path(rhs_key_transforms[:-1], include_root=False)\n+                    final_key = compile_json_path_for_has_key([rhs_key_transforms[-1]], include_root=False)\n+                    rhs_path = path_to_object + final_key\n+                else:\n+                    # Single key, treat as object key\n+                    rhs_path = compile_json_path_for_has_key(rhs_key_transforms, include_root=False)\n             else:\n-                rhs_key_transforms = [key]\n-            rhs_params.append(\n-                \"%s%s\"\n-                % (\n-                    lhs_json_path,\n-                    compile_json_path(rhs_key_transforms, include_root=False),\n-                )\n-            )\n+                # Simple string key, always treat as object key\n+                rhs_path = compile_json_path_for_has_key([key], include_root=False)\n+            \n+            rhs_params.append(\"%s%s\" % (lhs_json_path, rhs_path))\n         # Add condition for each key.\n         if self.logical_operator:\n             sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n@@ -387,25 +407,50 @@ class KeyTransformTextLookupMixin:\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n-        sql, params = HasKey(\n-            self.lhs.lhs,\n-            self.lhs.key_name,\n-        ).as_oracle(compiler, connection)\n-        if not self.rhs:\n-            return sql, params\n-        # Column doesn't have a key or IS NULL.\n-        lhs, lhs_params, _ = self.lhs.preprocess_lhs(compiler, connection)\n-        return \"(NOT %s OR %s IS NULL)\" % (sql, lhs), tuple(params) + tuple(lhs_params)\n+        # For numeric keys, use the original path compilation to handle array indices correctly\n+        try:\n+            int(self.lhs.key_name)\n+            # Numeric key - might be an array index, use original compile_json_path\n+            lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(compiler, connection)\n+            json_path = compile_json_path(lhs_key_transforms)\n+            if not self.rhs:\n+                sql = \"JSON_EXISTS(%s, '%s')\" % (lhs, json_path)\n+                return sql, tuple(lhs_params)\n+            else:\n+                sql = \"(NOT JSON_EXISTS(%s, '%s') OR %s IS NULL)\" % (lhs, json_path, lhs)\n+                return sql, tuple(lhs_params) * 2\n+        except ValueError:\n+            # Non-numeric key - use HasKey which treats it as an object key\n+            sql, params = HasKey(\n+                self.lhs.lhs,\n+                self.lhs.key_name,\n+            ).as_oracle(compiler, connection)\n+            if not self.rhs:\n+                return sql, params\n+            # Column doesn't have a key or IS NULL.\n+            lhs, lhs_params, _ = self.lhs.preprocess_lhs(compiler, connection)\n+            return \"(NOT %s OR %s IS NULL)\" % (sql, lhs), tuple(params) + tuple(lhs_params)\n \n     def as_sqlite(self, compiler, connection):\n         template = \"JSON_TYPE(%s, %%s) IS NULL\"\n         if not self.rhs:\n             template = \"JSON_TYPE(%s, %%s) IS NOT NULL\"\n-        return HasKey(self.lhs.lhs, self.lhs.key_name).as_sql(\n-            compiler,\n-            connection,\n-            template=template,\n-        )\n+        \n+        # For numeric keys, use the original path compilation to handle array indices correctly\n+        try:\n+            int(self.lhs.key_name)\n+            # Numeric key - might be an array index, use original compile_json_path\n+            lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(compiler, connection)\n+            json_path = compile_json_path(lhs_key_transforms)\n+            sql = template % lhs\n+            return sql, tuple(lhs_params) + (json_path,)\n+        except ValueError:\n+            # Non-numeric key - use HasKey which treats it as an object key\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sql(\n+                compiler,\n+                connection,\n+                template=template,\n+            )\n \n \n class KeyTransformIn(lookups.In):\n"}