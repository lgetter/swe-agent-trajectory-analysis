{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-11734", "model_patch": "diff --git a/debug_outerref.py b/debug_outerref.py\nnew file mode 100644\nindex 0000000000..4716ea39e1\n--- /dev/null\n+++ b/debug_outerref.py\n@@ -0,0 +1,98 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'tests.queries',\n+        ],\n+        SECRET_KEY='test-secret-key',\n+    )\n+\n+django.setup()\n+\n+from django.db.models import Exists, Q, OuterRef\n+from tests.queries.models import Number, Item, Tag, NamedCategory, Author, Note, ExtraInfo\n+\n+# Create the database tables\n+from django.core.management import execute_from_command_line\n+execute_from_command_line(['manage.py', 'migrate', '--run-syncdb'])\n+\n+# Create some test data\n+category = NamedCategory.objects.create(name=\"test_cat\")\n+tag = Tag.objects.create(name=\"test_tag\", category=category)\n+\n+# Create required dependencies\n+note = Note.objects.create(note=\"test_note\", misc=\"test_misc\")\n+extra_info = ExtraInfo.objects.create(info=\"test_info\")\n+author = Author.objects.create(name=\"test_author\", num=1, extra=extra_info)\n+\n+item = Item.objects.create(\n+    name=\"test_item\",\n+    created=\"2023-01-01 00:00:00\",\n+    creator=author,\n+    note=note\n+)\n+item.tags.add(tag)\n+\n+number = Number.objects.create(num=1, other_num=10)\n+\n+# Let's debug the OuterRef resolution\n+print(\"=== Debugging OuterRef resolution ===\")\n+\n+# Test 1: filter() - should work correctly\n+print(\"\\n1. Testing filter() with OuterRef:\")\n+subquery1 = Item.objects.filter(tags__category_id=OuterRef('pk'))\n+print(f\"Subquery SQL: {subquery1.query}\")\n+\n+# Test 2: exclude() - should show the problem\n+print(\"\\n2. Testing exclude() with OuterRef:\")\n+subquery2 = Item.objects.exclude(tags__category_id=OuterRef('pk'))\n+print(f\"Subquery SQL: {subquery2.query}\")\n+\n+# Test 3: filter(~Q()) - should show the problem\n+print(\"\\n3. Testing filter(~Q()) with OuterRef:\")\n+subquery3 = Item.objects.filter(~Q(tags__category_id=OuterRef('pk')))\n+print(f\"Subquery SQL: {subquery3.query}\")\n+\n+# Let's also check what happens when we manually create the Q objects\n+print(\"\\n4. Testing Q object creation:\")\n+q1 = Q(tags__category_id=OuterRef('pk'))\n+print(f\"Q object: {q1}\")\n+print(f\"Q object children: {q1.children}\")\n+\n+q2 = ~Q(tags__category_id=OuterRef('pk'))\n+print(f\"~Q object: {q2}\")\n+print(f\"~Q object children: {q2.children}\")\n+print(f\"~Q object negated: {q2.negated}\")\n+\n+# Let's see what happens when we resolve the OuterRef manually\n+print(\"\\n5. Testing OuterRef resolution:\")\n+outer_ref = OuterRef('pk')\n+print(f\"OuterRef: {outer_ref}\")\n+print(f\"OuterRef name: {outer_ref.name}\")\n+\n+# Create a dummy query to see how resolution works\n+from django.db.models.sql.query import Query\n+dummy_query = Query(Number)\n+print(f\"Dummy query model: {dummy_query.model}\")\n+\n+try:\n+    resolved = outer_ref.resolve_expression(dummy_query)\n+    print(f\"Resolved OuterRef: {resolved}\")\n+    print(f\"Resolved OuterRef type: {type(resolved)}\")\n+except Exception as e:\n+    print(f\"Error resolving OuterRef: {e}\")\n\\ No newline at end of file\ndiff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 2b59dd301a..dbfaceccf8 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -552,6 +552,30 @@ class ResolvedOuterRef(F):\n     \"\"\"\n     contains_aggregate = False\n \n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n+                           summarize=False, for_save=False, simple_col=False):\n+        # When resolving in a subquery context, we need to resolve the reference\n+        # to point to the outer query's table alias\n+        if query and hasattr(query, 'external_aliases') and query.external_aliases:\n+            # Try to resolve the reference using the outer query context\n+            # For 'pk' references, find the primary key field of the outer model\n+            if self.name == 'pk':\n+                # Find the outer query's model and primary key\n+                for alias in query.external_aliases:\n+                    table = query.alias_map.get(alias)\n+                    if table:\n+                        # Get the primary key field\n+                        if hasattr(table, 'table_name'):\n+                            # This is a BaseTable, find the model\n+                            for model in query.model._meta.apps.get_models():\n+                                if model._meta.db_table == table.table_name:\n+                                    pk_field = model._meta.pk\n+                                    from django.db.models.sql.datastructures import Col\n+                                    return Col(alias, pk_field, pk_field)\n+        \n+        # If we can't resolve using external aliases, use the parent implementation\n+        return super().resolve_expression(query, allow_joins, reuse, summarize, for_save, simple_col)\n+\n     def as_sql(self, *args, **kwargs):\n         raise ValueError(\n             'This queryset contains a reference to an outer query and may '\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea..7b11cee83b 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1702,7 +1702,14 @@ class Query(BaseExpression):\n         handle.\n         \"\"\"\n         filter_lhs, filter_rhs = filter_expr\n-        if isinstance(filter_rhs, F):\n+        from django.db.models.expressions import OuterRef\n+        if isinstance(filter_rhs, OuterRef):\n+            # OuterRef is already correct, no need to convert\n+            pass\n+        elif isinstance(filter_rhs, F):\n+            filter_expr = (filter_lhs, OuterRef(filter_rhs.name))\n+        elif hasattr(filter_rhs, '__class__') and filter_rhs.__class__.__name__ == 'ResolvedOuterRef':\n+            # If it's already a ResolvedOuterRef, convert it back to OuterRef\n             filter_expr = (filter_lhs, OuterRef(filter_rhs.name))\n         # Generate the inner query.\n         query = Query(self.model)\ndiff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 0000000000..cf30c4301b\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,106 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'tests.queries',\n+        ],\n+        SECRET_KEY='test-secret-key',\n+    )\n+\n+django.setup()\n+\n+from django.db.models import Exists, Q, OuterRef\n+from tests.queries.models import Number, Item, Tag, NamedCategory, Author, Note, ExtraInfo\n+\n+# Create the database tables\n+from django.core.management import execute_from_command_line\n+execute_from_command_line(['manage.py', 'migrate', '--run-syncdb'])\n+\n+# Create some test data\n+category = NamedCategory.objects.create(name=\"test_cat\")\n+tag = Tag.objects.create(name=\"test_tag\", category=category)\n+\n+# Create required dependencies\n+note = Note.objects.create(note=\"test_note\", misc=\"test_misc\")\n+extra_info = ExtraInfo.objects.create(info=\"test_info\")\n+author = Author.objects.create(name=\"test_author\", num=1, extra=extra_info)\n+\n+item = Item.objects.create(\n+    name=\"test_item\",\n+    created=\"2023-01-01 00:00:00\",\n+    creator=author,\n+    note=note\n+)\n+item.tags.add(tag)\n+\n+number = Number.objects.create(num=1, other_num=10)\n+\n+print(\"Testing OuterRef with filter() - should work:\")\n+try:\n+    qs = Number.objects.annotate(\n+        foo=Exists(\n+            Item.objects.filter(tags__category_id=OuterRef('pk'))\n+        )\n+    ).filter(foo=True)\n+    print(f\"Query: {qs.query}\")\n+    print(f\"Result: {list(qs)}\")\n+    print(\"\u2713 filter() works\")\n+except Exception as e:\n+    print(f\"\u2717 filter() failed: {e}\")\n+\n+print(\"\\nTesting OuterRef with exclude() - should fail:\")\n+try:\n+    qs = Number.objects.annotate(\n+        foo=Exists(\n+            Item.objects.exclude(tags__category_id=OuterRef('pk'))\n+        )\n+    ).filter(foo=True)\n+    print(f\"Query: {qs.query}\")\n+    print(f\"Result: {list(qs)}\")\n+    print(\"\u2713 exclude() works\")\n+except Exception as e:\n+    print(f\"\u2717 exclude() failed: {e}\")\n+\n+print(\"\\nTesting OuterRef with filter(~Q()) - should fail:\")\n+try:\n+    qs = Number.objects.annotate(\n+        foo=Exists(\n+            Item.objects.filter(~Q(tags__category_id=OuterRef('pk')))\n+        )\n+    ).filter(foo=True)\n+    print(f\"Query: {qs.query}\")\n+    print(f\"Result: {list(qs)}\")\n+    print(\"\u2713 filter(~Q()) works\")\n+except Exception as e:\n+    print(f\"\u2717 filter(~Q()) failed: {e}\")\n+\n+# Let's try to trigger the actual error by using the subquery directly\n+print(\"\\nTesting direct subquery usage - should trigger the error:\")\n+try:\n+    subquery = Item.objects.exclude(tags__category_id=OuterRef('pk'))\n+    print(f\"Subquery: {subquery.query}\")\n+    print(\"\u2717 This should have failed!\")\n+except Exception as e:\n+    print(f\"\u2713 Direct subquery failed as expected: {e}\")\n+\n+try:\n+    subquery = Item.objects.filter(~Q(tags__category_id=OuterRef('pk')))\n+    print(f\"Subquery: {subquery.query}\")\n+    print(\"\u2717 This should have failed!\")\n+except Exception as e:\n+    print(f\"\u2713 Direct subquery failed as expected: {e}\")\n\\ No newline at end of file\ndiff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\nindex 668d5e6ad6..ded783be37 100644\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -1,9 +1,9 @@\n from django.db import connection\n-from django.db.models import Exists, F, IntegerField, OuterRef, Value\n+from django.db.models import Exists, F, IntegerField, OuterRef, Value, Q\n from django.db.utils import DatabaseError, NotSupportedError\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n-from .models import Number, ReservedName\n+from .models import Number, ReservedName, Item\n \n \n @skipUnlessDBFeature('supports_select_union')\n@@ -285,3 +285,26 @@ class QuerySetSetOperationTests(TestCase):\n                         msg % (operation, combinator),\n                     ):\n                         getattr(getattr(qs, combinator)(qs), operation)()\n+\n+    def test_exists_exclude(self):\n+        # filter()\n+        qs = Number.objects.annotate(\n+            foo=Exists(\n+                Item.objects.filter(tags__category_id=OuterRef('pk'))\n+            )\n+        ).filter(foo=True)\n+        print(qs)  # works\n+        # exclude()\n+        qs = Number.objects.annotate(\n+            foo=Exists(\n+                Item.objects.exclude(tags__category_id=OuterRef('pk'))\n+            )\n+        ).filter(foo=True)\n+        print(qs)  # crashes\n+        # filter(~Q())\n+        qs = Number.objects.annotate(\n+            foo=Exists(\n+                Item.objects.filter(~Q(tags__category_id=OuterRef('pk')))\n+            )\n+        ).filter(foo=True)\n+        print(qs)  # crashes\n"}