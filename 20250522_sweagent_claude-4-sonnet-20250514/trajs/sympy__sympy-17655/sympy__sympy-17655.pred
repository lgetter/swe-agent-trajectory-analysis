{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "sympy__sympy-17655", "model_patch": "diff --git a/sympy/geometry/point.py b/sympy/geometry/point.py\nindex 7c978c47be..9e69fff3f4 100644\n--- a/sympy/geometry/point.py\n+++ b/sympy/geometry/point.py\n@@ -32,6 +32,7 @@\n from sympy.core.numbers import Float\n from sympy.core.evaluate import global_evaluate\n from sympy.core.add import Add\n+from sympy.core.mul import Mul\n from sympy.utilities.iterables import uniq\n from sympy.utilities.misc import filldedent, func_name, Undecidable\n \n@@ -213,6 +214,25 @@ def __add__(self, other):\n         sympy.geometry.point.Point.translate\n \n         \"\"\"\n+        # Handle Mul expressions that contain a Point (e.g., 2.0*Point(1, 1))\n+        if isinstance(other, Mul):\n+            # Check if the Mul expression contains exactly one Point\n+            point_args = [arg for arg in other.args if isinstance(arg, Point)]\n+            if len(point_args) == 1:\n+                # Extract the Point and the scalar factor\n+                point = point_args[0]\n+                scalar_args = [arg for arg in other.args if not isinstance(arg, Point)]\n+                if scalar_args:\n+                    # Multiply the scalar factors together\n+                    scalar = Mul(*scalar_args)\n+                    # Create a new Point by multiplying the original point by the scalar\n+                    scaled_point = point * scalar\n+                    # Now add this scaled point to self\n+                    return self + scaled_point\n+                else:\n+                    # If there are no scalar factors, just add the point directly\n+                    return self + point\n+        \n         try:\n             s, o = Point._normalize_dimension(self, Point(other, evaluate=False))\n         except TypeError:\n@@ -278,6 +298,42 @@ def __mul__(self, factor):\n         coords = [simplify(x*factor) for x in self.args]\n         return Point(coords, evaluate=False)\n \n+    def __rmul__(self, factor):\n+        \"\"\"Multiply point's coordinates by a factor (right multiplication).\n+\n+        This method handles cases like `factor * point` where the factor\n+        is on the left side of the multiplication operator.\n+\n+        Notes\n+        =====\n+\n+        >>> from sympy.geometry.point import Point\n+\n+        This enables both `point * factor` and `factor * point` to work:\n+\n+        >>> Point(1, 2) * 3\n+        Point2D(3, 6)\n+        >>> 3 * Point(1, 2)\n+        Point2D(3, 6)\n+\n+        See Also\n+        ========\n+\n+        sympy.geometry.point.Point.__mul__\n+        sympy.geometry.point.Point.scale\n+        \"\"\"\n+        return self.__mul__(factor)\n+\n+    def as_coeff_Mul(self, rational=False):\n+        \"\"\"Efficiently extract the coefficient of a product.\n+        \n+        For a Point, this always returns (S.One, self) since a Point\n+        cannot be decomposed into a coefficient and a remaining factor.\n+        \n+        This method is required for compatibility with SymPy's Mul class.\n+        \"\"\"\n+        return S.One, self\n+\n     def __neg__(self):\n         \"\"\"Negate the point.\"\"\"\n         coords = [-x for x in self.args]\n"}