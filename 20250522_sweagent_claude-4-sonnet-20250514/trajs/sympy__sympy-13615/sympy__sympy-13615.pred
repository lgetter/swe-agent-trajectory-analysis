{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "sympy__sympy-13615", "model_patch": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 917717bb74..8878013566 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -1000,8 +1000,82 @@ def _complement(self, other):\n \n         if isinstance(other, FiniteSet):\n             nums = [m for m in other.args if m.is_number]\n-            if nums == []:\n+            syms = [m for m in other.args if not m.is_number]\n+            \n+            if nums == [] and syms == []:\n                 return None\n+            \n+            # Handle case where we have a mixture of numbers and symbols\n+            if nums != [] and syms != []:\n+                # Remove numbers that are definitely contained in this interval\n+                remaining_nums = []\n+                undetermined = False\n+                \n+                for n in nums:\n+                    try:\n+                        contains_result = self.contains(n)\n+                        if contains_result is S.true:\n+                            # Definitely contained, remove it\n+                            continue\n+                        elif contains_result is S.false:\n+                            # Definitely not contained, keep it\n+                            remaining_nums.append(n)\n+                        else:\n+                            # Undetermined (symbolic), keep it and mark as undetermined\n+                            remaining_nums.append(n)\n+                            undetermined = True\n+                    except (TypeError, ValueError):\n+                        # If we can't determine containment, keep the number\n+                        remaining_nums.append(n)\n+                        undetermined = True\n+                \n+                remaining_elements = remaining_nums + syms\n+                \n+                if remaining_elements:\n+                    if syms or undetermined:\n+                        # If there are symbols or undetermined containment, return a Complement\n+                        return Complement(FiniteSet(*remaining_elements), self, evaluate=False)\n+                    else:\n+                        # Only numbers remain and all containment is determined, return them as a FiniteSet\n+                        return FiniteSet(*remaining_elements)\n+                else:\n+                    return S.EmptySet\n+            \n+            # Handle case where we have only numbers\n+            elif nums != [] and syms == []:\n+                remaining_nums = []\n+                undetermined = False\n+                \n+                for n in nums:\n+                    try:\n+                        contains_result = self.contains(n)\n+                        if contains_result is S.true:\n+                            # Definitely contained, remove it\n+                            continue\n+                        elif contains_result is S.false:\n+                            # Definitely not contained, keep it\n+                            remaining_nums.append(n)\n+                        else:\n+                            # Undetermined (symbolic), keep it and mark as undetermined\n+                            remaining_nums.append(n)\n+                            undetermined = True\n+                    except (TypeError, ValueError):\n+                        # If we can't determine containment, keep the number\n+                        remaining_nums.append(n)\n+                        undetermined = True\n+                \n+                if remaining_nums:\n+                    if undetermined:\n+                        # Return a Complement if containment is undetermined\n+                        return Complement(FiniteSet(*remaining_nums), self, evaluate=False)\n+                    else:\n+                        return FiniteSet(*remaining_nums)\n+                else:\n+                    return S.EmptySet\n+            \n+            # Handle case where we have only symbols (no numbers)\n+            elif nums == [] and syms != []:\n+                return None  # Let the base class handle this\n \n         return Set._complement(self, other)\n \n"}